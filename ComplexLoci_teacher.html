<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Complex Loci – Normal / Reverse</title>
  <style>
    :root{
      --bg:#f5f7fb; --card:#fff; --ink:#111; --muted:#667085;
      --line:#e6e8ee; --accent:#f59e0b; --good:#16a34a; --bad:#dc2626;
    }
    body{margin:0; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--ink);}
    .wrap{max-width:1150px; margin:0 auto; padding:18px;}
    .top{display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    h1{font-size:18px; margin:0;}
    .pillrow{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
    .pill{
      background:var(--card); border:1px solid var(--line); border-radius:999px;
      padding:6px 10px; font-size:13px; color:var(--muted);
      display:flex; gap:8px; align-items:center;
    }
    .pill strong{color:var(--ink); font-weight:900;}
    select, input[type="text"]{
      border:1px solid var(--line);
      border-radius:12px;
      padding:8px 10px;
      background:#fff;
      color:var(--ink);
      font-weight:700;
      font-size:14px;
      outline:none;
    }
    select{border-radius:999px; padding:6px 10px; font-size:13px;}
    .card{
      margin-top:12px;
      background:var(--card); border:1px solid var(--line); border-radius:16px;
      box-shadow:0 10px 18px rgba(0,0,0,.05);
      padding:16px;
    }
    .prompt{
      font-size:18px;
      line-height:1.35;
      padding:10px 12px;
      border:1px dashed var(--line);
      border-radius:12px;
      background:#fcfcff;
      overflow:auto;
    }
    .sub{margin:10px 0 0; color:var(--muted); font-size:13px;}
    .grid{display:grid; gap:10px; margin-top:12px;}
    @media (max-width:720px){ .prompt{font-size:17px;} }

    .opt{
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      display:flex;
      gap:12px;
      align-items:center;
      cursor:pointer;
      user-select:none;
      transition:.12s transform, .12s box-shadow, .12s border-color, .12s background;
      background:#fff;
    }
    .opt:hover{transform:translateY(-1px); box-shadow:0 8px 14px rgba(0,0,0,.05);}
    .opt .tag{
      width:34px; height:34px; border-radius:10px;
      display:grid; place-items:center;
      border:1px solid var(--line); color:var(--muted);
      font-weight:900;
      flex:0 0 auto;
    }
    .opt .txt{font-size:16px;}
    .opt.selected{border-color: rgba(245,158,11,.55); background: rgba(245,158,11,.08);}
    .opt.selected .tag{border-color: rgba(245,158,11,.65); color: var(--ink); background: rgba(245,158,11,.12);}
    .opt.reveal-good{border-color:rgba(22,163,74,.45); background:rgba(22,163,74,.06);}
    .opt.reveal-bad{border-color:rgba(220,38,38,.40); background:rgba(220,38,38,.05);}

    .controls{
      margin-top:14px;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    button{
      border:0;
      background:var(--accent);
      color:#111;
      padding:10px 14px;
      border-radius:12px;
      font-weight:900;
      cursor:pointer;
      box-shadow:0 10px 18px rgba(245,158,11,.20);
      transition:.12s transform, .12s opacity;
    }
    button:hover{transform:translateY(-1px);}
    button:disabled{opacity:.45; cursor:not-allowed; transform:none; box-shadow:none;}
    .ghost{
      background:#fff;
      border:1px solid var(--line);
      color:var(--ink);
      box-shadow:none;
      font-weight:800;
    }
    .msg{
      font-size:14px; color:var(--muted);
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:#fff;
      flex:1 1 auto;
      min-width:280px;
    }
    .msg.good{border-color:rgba(22,163,74,.35); color:var(--good); background:rgba(22,163,74,.06);}
    .msg.bad{border-color:rgba(220,38,38,.35); color:var(--bad); background:rgba(220,38,38,.06);}
    .tiny{font-size:12px; color:var(--muted); margin-top:6px;}

    .extra{
      margin-top:12px;
      border-top:1px solid var(--line);
      padding-top:12px;
      display:none;
    }
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .row label{font-size:13px; color:var(--muted); font-weight:900;}
    .hint{font-size:12px; color:var(--muted); margin-top:6px;}
    .chk{display:flex; align-items:center; gap:8px; cursor:pointer; user-select:none; font-weight:900; color:var(--ink);}
    .chk input{transform:scale(1.1);}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
  
    /* ===== overlay (start screen) ===== */
    .overlay{
      position:fixed; inset:0; background:rgba(17,17,17,.55);
      display:flex; align-items:center; justify-content:center;
      padding:18px; z-index:9999;
    }
    .overlayCard{
      width:min(720px, 100%);
      background:var(--card);
      border:1px solid var(--line);
      border-radius:18px;
      box-shadow:0 18px 40px rgba(0,0,0,.20);
      padding:18px;
    }
    .overlayCard h2{margin:0 0 6px; font-size:18px;}
    .overlayCard p{margin:0 0 12px; color:var(--muted); font-weight:700;}
    .lociPick{display:grid; gap:10px; grid-template-columns:repeat(2, minmax(0,1fr));}
    @media (max-width:560px){ .lociPick{grid-template-columns:1fr;} }
    .pick{
      display:flex; gap:10px; align-items:center;
      border:1px solid var(--line); border-radius:14px; padding:10px 12px;
      background:#fff; font-weight:900; cursor:pointer; user-select:none;
    }
    .pick input{transform:scale(1.15);}
    .overlayBtns{display:flex; justify-content:flex-end; margin-top:12px;}
    .overlayNote{margin-top:10px; font-size:13px; color:var(--bad); font-weight:900;}
    /* ===== diagram panel ===== */
    .diagramPanel{
      margin-top:12px;
      border-top:1px solid var(--line);
      padding-top:12px;
      display:none;
    }
    .diagramTop{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;}
    .toggles{display:flex; gap:12px; flex-wrap:wrap; align-items:center;}
    .svgWrap{
      margin-top:10px;
      background:#fff;
      border:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
    }
    .svgWrap svg{display:block; width:100%; height:auto;}

  </style>

  <script>
    window.MathJax = { tex: {inlineMath: [['\\(','\\)'], ['$', '$']]} };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>

  <div id="startOverlay" class="overlay">
    <div class="overlayCard">
      <h2>Choose loci for this session</h2>
      <p>Select at least one locus type for the next rounds.</p>
      <div class="lociPick">
        <label class="pick"><input type="checkbox" data-type="0" checked /> <span>\(|z-a|=k\)</span></label>
        <label class="pick"><input type="checkbox" data-type="1" checked /> <span>\(\arg(z-a)=k\)</span></label>
        <label class="pick"><input type="checkbox" data-type="2" checked /> <span>\(|z-a|=|z-b|\)</span></label>
        <label class="pick"><input type="checkbox" data-type="3" checked /> <span>\(\arg(z-a)=\arg(z-b)\)</span></label>
      </div>

      <div class="startExtras">
        <div class="startRow">
          <div class="startField">
            <div class="startLbl">Number of options</div>
            <select id="startNumOptSel" aria-label="Number of options"></select>
          </div>
          <div class="startField">
            <div class="startLbl">Mode</div>
            <label class="pick"><input type="radio" name="startMode" value="normal" checked /> <span>Select point</span></label>
            <label class="pick"><input type="radio" name="startMode" value="reverse" /> <span>Select locus</span></label>
          </div>
        </div>
      </div>

      <div class="overlayBtns">
        <button id="startBtn">Start</button>
      </div>
      <div class="overlayNote" id="startNote"></div>
    </div>
  </div>

  <div class="wrap">
    <div class="top">
      <h1>Complex Loci</h1>
      <div class="pillrow">
        <div class="pill">Level: <strong id="levelLbl">1</strong></div>
        <div class="pill">Mode: <strong id="modeLbl">Normal</strong></div>
        <div class="pill">Options: <strong id="numOptLbl">—</strong></div>
    </div>

    <div class="card">
      <div class="prompt" id="promptBox">Loading…</div>
      <div class="sub" id="subLine">Select answer(s), then click <b>Check</b>. (Hold <b>Shift</b> and click Check to reveal.)</div>

      <div class="grid" id="options"></div>

      <div class="extra" id="extraPanel">
        <div class="row" id="extraRow"></div>
        <div class="hint" id="extraHint"></div>
      </div>

      <div class="controls">
        <button id="checkBtn">Check</button>
        <button id="nextBtn" class="ghost" style="display:none;">Next level</button>
        <button id="reviewBtn" class="ghost" style="display:none;">Review on Argand diagram</button>
        <div class="msg" id="msgBox">Select your answer(s).</div>
      </div>

      
      <div class="diagramPanel" id="diagramPanel">
        <div class="diagramTop">
          <div class="toggles" id="diagramToggles"></div>
          <button id="closeDiagramBtn" class="ghost">Hide diagram</button>
        </div>
        <div class="svgWrap">
          <svg id="argandSvg" viewBox="0 0 520 520" aria-label="Argand diagram"></svg>
        </div>
      </div>

      <div class="tiny" id="cooldownLbl"></div>
    </div>
  </div>

<script>
(() => {
  // ================== small helpers ==================
  const choice = arr => arr[Math.floor(Math.random()*arr.length)];
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function nearly(a,b,eps=1e-6){ return Math.abs(a-b) <= eps; }
  function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ [a,b]=[b,a%b]; } return a||1; }

  function add(z,w){ return {re:z.re+w.re, im:z.im+w.im}; }
  function sub(z,w){ return {re:z.re-w.re, im:z.im-w.im}; }
  function mulScalar(z,t){ return {re:z.re*t, im:z.im*t}; }
  function norm(z){ return Math.hypot(z.re,z.im); }
  function dot(a,b){ return a.re*b.re + a.im*b.im; }
  function cross(a,b){ return a.re*b.im - a.im*b.re; }
  function arg(z){ return Math.atan2(z.im, z.re); }
  function wrapPi(x){ while (x<=-Math.PI) x+=2*Math.PI; while (x> Math.PI) x-=2*Math.PI; return x; }
  function sameArg(v1,v2){ return Math.abs(cross(v1,v2)) <= 1e-6 && dot(v1,v2) > 1e-6; }

  function randomComplex(range=6, step=0.5){
    const vals = [];
    for (let x=-range; x<=range+1e-9; x+=step) vals.push(+x.toFixed(3));
    return {re: choice(vals), im: choice(vals)};
  }
  function randomNonEqualComplex(existing, range=6, step=0.5){
    for (let tries=0; tries<8000; tries++){
      const z = randomComplex(range, step);
      let ok = true;
      for (const e of existing){
        if (Math.hypot(z.re-e.re, z.im-e.im) < 1e-9){ ok=false; break; }
      }
      if (ok) return z;
    }
    return randomComplex(range, step);
  }

  // ================== TeX formatting (vertical fractions + upright i) ==================
  function texNum(x){
    const nearestInt = Math.round(x);
    if (nearly(x, nearestInt, 1e-9)) return String(nearestInt);

    const q = Math.round(x*4);
    if (nearly(x, q/4, 1e-9)){
      const n=q, d=4;
      const s = n<0 ? "-" : "";
      const an=Math.abs(n);
      const g=gcd(an,d);
      const nn=an/g, dd=d/g;
      if (dd===1) return s+String(nn);
      return s+"\\frac{"+nn+"}{"+dd+"}";
    }
    const h = Math.round(x*2);
    if (nearly(x, h/2, 1e-9)){
      const n=h, d=2;
      const s = n<0 ? "-" : "";
      const an=Math.abs(n);
      const g=gcd(an,d);
      const nn=an/g, dd=d/g;
      if (dd===1) return s+String(nn);
      return s+"\\frac{"+nn+"}{"+dd+"}";
    }
    const s = (x<0) ? "-" : "";
    return s + Math.abs(x).toFixed(2).replace(/\.00$/,'');
  }

  function texZMinus(a){
    const parts = ["z"];
    const re=a.re, im=a.im;
    if (!nearly(re,0,1e-9)) parts.push((re>0 ? "-" : "+") + texNum(Math.abs(re)));
    if (!nearly(im,0,1e-9)){
      const sign = (im>0) ? "-" : "+";
      const mag = Math.abs(im);
      const magTex = texNum(mag);
      const iTex = nearly(mag,1,1e-9) ? "\\mathrm{i}" : magTex + "\\mathrm{i}";
      parts.push(sign + iTex);
    }
    return parts.join("");
  }

  function texZEquals(z){
    const re0=nearly(z.re,0,1e-9), im0=nearly(z.im,0,1e-9);
    const a = texNum(z.re);
    const b = texNum(Math.abs(z.im));
    if (im0) return "z=" + a;
    if (re0){
      const sign = z.im<0 ? "-" : "";
      const iPart = nearly(Math.abs(z.im),1,1e-9) ? "\\mathrm{i}" : b + "\\mathrm{i}";
      return "z=" + sign + iPart;
    }
    const sign = z.im<0 ? "-" : "+";
    const iPart = nearly(Math.abs(z.im),1,1e-9) ? "\\mathrm{i}" : b + "\\mathrm{i}";
    return "z=" + a + sign + iPart;
  }

  // ================== exact angles in (-pi, pi] ==================
  const ANGLES = [
    {n:-11, d:12},{n:-5,d:6},{n:-3,d:4},{n:-2,d:3},{n:-7,d:12},{n:-1,d:2},{n:-5,d:12},{n:-1,d:3},{n:-1,d:4},{n:-1,d:6},{n:-1,d:12},
    {n:0,d:1},
    {n:1,d:12},{n:1,d:6},{n:1,d:4},{n:1,d:3},{n:5,d:12},{n:1,d:2},{n:7,d:12},{n:2,d:3},{n:3,d:4},{n:5,d:6},{n:11,d:12},
    {n:1,d:1} // pi
  ];
  function angleToTex(fr){
    const n=fr.n, d=fr.d;
    if (n===0) return "0";
    if (d===1){
      if (n===1) return "\\pi";
      if (n===-1) return "-\\pi";
      return (n<0? "-" : "") + String(Math.abs(n)) + "\\pi";
    }
    const absN=Math.abs(n);
    const num = (absN===1) ? "\\pi" : absN + "\\pi";
    const tex = "\\frac{"+num+"}{"+d+"}";
    return (n<0) ? "-" + tex : tex;
  }
  function angleToRadians(fr){ return (fr.n/fr.d)*Math.PI; }

  // ================== parsing (complex + locus) ==================
  function parseRational(t){
    if (t === "" || t === "+") return 0;
    if (t === "-") return 0;
    const m = t.match(/^([+-]?\d+)(?:\/(\d+))?$/);
    if (!m) return null;
    const a = parseInt(m[1],10);
    const b = m[2] ? parseInt(m[2],10) : 1;
    if (b===0) return null;
    return a/b;
  }

  function parseComplex(str){
    if (!str) return null;
    let s = str.replace(/\s+/g,'').toLowerCase().replace(/\u2212/g,'-').replace(/j/g,'i');
    if (s==="i") return {re:0, im:1};
    if (s==="-i") return {re:0, im:-1};

    if (!s.includes('i')){
      const re=parseRational(s);
      if (re===null) return null;
      return {re, im:0};
    }

    if (s.endsWith('i')) s = s.slice(0,-1); else return null;

    let split=-1;
    for (let i=1;i<s.length;i++){
      if (s[i]==='+' || s[i]==='-') split=i;
    }

    let reStr, imStr;
    if (split===-1){ reStr="0"; imStr=s; }
    else { reStr=s.slice(0,split); imStr=s.slice(split); }

    if (imStr==="" || imStr==="+") imStr="1";
    if (imStr==="-") imStr="-1";

    const re=parseRational(reStr);
    const im=parseRational(imStr);
    if (re===null || im===null) return null;
    return {re, im};
  }

  function parseAngleExpr(s){
    if (!s) return null;
    let t = s.replace(/\s+/g,'').toLowerCase().replace(/\u2212/g,'-').replace(/π/g,'pi');
    if (t==="0") return 0;
    if (t==="pi") return Math.PI;
    if (t==="-pi") return -Math.PI;

    if (!t.includes("pi")){
      const v=Number(t);
      if (!Number.isFinite(v)) return null;
      let w=v; while (w<=-Math.PI) w+=2*Math.PI; while (w>Math.PI) w-=2*Math.PI;
      return w;
    }

    let sign=1;
    if (t.startsWith('-')){ sign=-1; t=t.slice(1); }
    const parts=t.split("pi");
    const before=parts[0], after=parts[1];
    let coef=1;

    if (before!==""){
      const b=before.replace(/\*$/,'');
      const r=parseRational(b);
      if (r===null) return null;
      coef=r;
    }
    let denom=1;
    if (after){
      const m=after.match(/^\/(\d+)$/);
      if (!m) return null;
      denom=parseInt(m[1],10);
      if (!denom) return null;
    }
    let val = sign*coef*Math.PI/denom;
    while (val<=-Math.PI) val+=2*Math.PI;
    while (val>Math.PI) val-=2*Math.PI;
    return val;
  }

  // Required formats:
  // |z-a|=k
  // arg(z-a)=k
  // |z-a|=|z-b|
  // arg(z-a)=arg(z-b)
  function parseLocusString(input){
    if (!input) return null;
    let s = input.trim().toLowerCase().replace(/\u2212/g,'-');
    s = s.replace(/∣/g,'|');
    const t = s.replace(/\s+/g,'');

    function extractZA(expr){
      if (!expr.startsWith('z')) return null;
      const rest = expr.slice(1);      // e.g. "-1+2i"
      const w = parseComplex(rest);
      if (!w) return null;
      return {re:-w.re, im:-w.im};     // a = -rest
    }

    let m = t.match(/^arg\((z[^)]*)\)=arg\((z[^)]*)\)$/);
    if (m){
      const a = extractZA(m[1]);
      const b = extractZA(m[2]);
      if (!a || !b) return null;
      return {typeId:3, a, b};
    }

    m = t.match(/^\|(z[^|]*)\|=\|(z[^|]*)\|$/);
    if (m){
      const a = extractZA(m[1]);
      const b = extractZA(m[2]);
      if (!a || !b) return null;
      return {typeId:2, a, b};
    }

    m = t.match(/^arg\((z[^)]*)\)=([^]+)$/);
    if (m){
      const a = extractZA(m[1]);
      if (!a) return null;
      const k = parseAngleExpr(m[2]);
      if (k===null) return null;
      return {typeId:1, a, k};
    }

    m = t.match(/^\|(z[^|]*)\|=([^]+)$/);
    if (m){
      const a = extractZA(m[1]);
      if (!a) return null;
      const k = parseRational(m[2]);
      if (k===null || k<0) return null;
      return {typeId:0, a, k};
    }

    return null;
  }

  // ================== DOM refs ==================
  const el = {
    levelLbl: document.getElementById("levelLbl"),
    modeLbl: document.getElementById("modeLbl"),
    numOptLbl: document.getElementById("numOptLbl"),
    promptBox: document.getElementById("promptBox"),
    subLine: document.getElementById("subLine"),
    options: document.getElementById("options"),
    extraPanel: document.getElementById("extraPanel"),
    extraRow: document.getElementById("extraRow"),
    extraHint: document.getElementById("extraHint"),
    checkBtn: document.getElementById("checkBtn"),
    nextBtn: document.getElementById("nextBtn"),
    msgBox: document.getElementById("msgBox"),
    cooldownLbl: document.getElementById("cooldownLbl"),
    reviewBtn: document.getElementById("reviewBtn"),
    diagramPanel: document.getElementById("diagramPanel"),
    diagramToggles: document.getElementById("diagramToggles"),
    argandSvg: document.getElementById("argandSvg"),
    closeDiagramBtn: document.getElementById("closeDiagramBtn"),
    startOverlay: document.getElementById("startOverlay"),
    startBtn: document.getElementById("startBtn"),
    startNote: document.getElementById("startNote"),
  };

  function typeset(){
    if (window.MathJax && window.MathJax.typesetPromise){
      window.MathJax.typesetPromise().catch(()=>{});
    }
  }

  function setGridColumns(n){
    if (n >= 25) el.options.style.gridTemplateColumns = "repeat(6, minmax(0,1fr))";
    else if (n >= 21) el.options.style.gridTemplateColumns = "repeat(5, minmax(0,1fr))";
    else if (n >= 16) el.options.style.gridTemplateColumns = "repeat(4, minmax(0,1fr))";
    else if (n >= 10) el.options.style.gridTemplateColumns = "repeat(3, minmax(0,1fr))";
    else el.options.style.gridTemplateColumns = (window.innerWidth <= 720) ? "1fr" : "repeat(2, minmax(0,1fr))";
  }

  function setMsg(text, kind=""){
    el.msgBox.classList.remove("good","bad");
    if (kind) el.msgBox.classList.add(kind);
    el.msgBox.textContent = text;
  }

  
  // ================== Argand diagram (review) ==================
  const DIAG = { xmin:-12, xmax:12, ymin:-12, ymax:12, W:520, H:520, pad:40 };

  function xToSvg(x){ return DIAG.pad + (x - DIAG.xmin) * ( (DIAG.W-2*DIAG.pad) / (DIAG.xmax-DIAG.xmin) ); }
  function yToSvg(y){ return DIAG.H - DIAG.pad - (y - DIAG.ymin) * ( (DIAG.H-2*DIAG.pad) / (DIAG.ymax-DIAG.ymin) ); }

  function svgEl(name, attrs={}, children=[]){
    const n = document.createElementNS("http://www.w3.org/2000/svg", name);
    for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, String(v));
    for (const c of children) n.appendChild(c);
    return n;
  }

  function svgText(x,y,txt, attrs={}){
    return svgEl("text", {x, y, ...attrs}, [document.createTextNode(txt)]);
  }

  function lineToBounds(p, dir){
    // Intersect parametric p + t dir with bounding box; return [tmin,tmax]
    const ts = [];
    const eps=1e-9;
    if (Math.abs(dir.re)>eps){
      ts.push((DIAG.xmin - p.re)/dir.re);
      ts.push((DIAG.xmax - p.re)/dir.re);
    }
    if (Math.abs(dir.im)>eps){
      ts.push((DIAG.ymin - p.im)/dir.im);
      ts.push((DIAG.ymax - p.im)/dir.im);
    }
    const pts = ts.map(t => ({t, x:p.re + t*dir.re, y:p.im + t*dir.im}))
                 .filter(o => o.x>=DIAG.xmin-1e-6 && o.x<=DIAG.xmax+1e-6 && o.y>=DIAG.ymin-1e-6 && o.y<=DIAG.ymax+1e-6)
                 .sort((a,b)=>a.t-b.t);
    if (pts.length<2) return null;
    return [pts[0].t, pts[pts.length-1].t];
  }

  function buildGrid(){
    const g = svgEl("g");
    // grid
    for (let x=Math.ceil(DIAG.xmin); x<=Math.floor(DIAG.xmax); x++){
      const isAxis = (x===0);
      g.appendChild(svgEl("line", {
        x1:xToSvg(x), y1:yToSvg(DIAG.ymin), x2:xToSvg(x), y2:yToSvg(DIAG.ymax),
        stroke: isAxis ? "#111" : "#e6e8ee",
        "stroke-width": isAxis ? 2 : 1
      }));
      if (!isAxis) g.appendChild(svgText(xToSvg(x), yToSvg(0)+14, String(x), {fill:"#667085","font-size":"12","text-anchor":"middle"}));
    }
    for (let y=Math.ceil(DIAG.ymin); y<=Math.floor(DIAG.ymax); y++){
      const isAxis = (y===0);
      g.appendChild(svgEl("line", {
        x1:xToSvg(DIAG.xmin), y1:yToSvg(y), x2:xToSvg(DIAG.xmax), y2:yToSvg(y),
        stroke: isAxis ? "#111" : "#e6e8ee",
        "stroke-width": isAxis ? 2 : 1
      }));
      if (!isAxis) g.appendChild(svgText(xToSvg(0)+16, yToSvg(y)+4, String(y), {fill:"#667085","font-size":"12"}));
    }
    // axis arrows
    g.appendChild(svgEl("path", {d:`M ${xToSvg(DIAG.xmax)} ${yToSvg(0)} l -10 -6 l 0 12 Z`, fill:"#111"}));
    g.appendChild(svgEl("path", {d:`M ${xToSvg(0)} ${yToSvg(DIAG.ymax)} l -6 10 l 12 0 Z`, fill:"#111"}));
    return g;
  }

  function drawTickCross(x,y, kind){
    // kind: "tick" | "cross"
    const s=9;
    if (kind==="cross"){
      return svgEl("g", {}, [
        svgEl("line",{x1:x-s,y1:y-s,x2:x+s,y2:y+s,stroke:"#dc2626","stroke-width":3,"stroke-linecap":"round"}),
        svgEl("line",{x1:x-s,y1:y+s,x2:x+s,y2:y-s,stroke:"#dc2626","stroke-width":3,"stroke-linecap":"round"})
      ]);
    }
    // tick
    return svgEl("path", {
      d:`M ${x-10} ${y+1} L ${x-2} ${y+10} L ${x+12} ${y-8}`,
      fill:"none", stroke:"#16a34a","stroke-width":3,"stroke-linecap":"round","stroke-linejoin":"round"
    });
  }

  function drawStar(x,y){
    const r1=10, r2=4;
    const pts=[];
    for (let k=0;k<10;k++){
      const a = -Math.PI/2 + k*Math.PI/5;
      const r = (k%2===0)?r1:r2;
      pts.push([x + r*Math.cos(a), y + r*Math.sin(a)]);
    }
    return svgEl("polygon", {points: pts.map(p=>p.join(",")).join(" "), fill:"#f59e0b", stroke:"#111","stroke-width":1});
  }

  function locusPath(L, stroke, dashed=false){
    const g = svgEl("g");
    const sw = 3;

    if (L.typeId===0){
      const a=L.a, r=L.k;
      const pts=[];
      for (let k=0;k<=240;k++){
        const t=2*Math.PI*k/240;
        const x=a.re + r*Math.cos(t);
        const y=a.im + r*Math.sin(t);
        pts.push([xToSvg(x), yToSvg(y)]);
      }
      const d="M "+pts.map(p=>p.join(" ")).join(" L ");
      g.appendChild(svgEl("path",{d, fill:"none", stroke, "stroke-width":sw, "stroke-linecap":"round", "stroke-linejoin":"round", "stroke-dasharray": dashed ? "7 7":"0"}));
      return g;
    }

    if (L.typeId===1){
      const a=L.a;
      const dir={re:Math.cos(L.theta), im:Math.sin(L.theta)};
      const seg = lineToBounds(a, dir);
      if (!seg) return g;
      const t0 = Math.max(0.001, seg[0]); // ray, avoid drawing through a backwards
      const t1 = seg[1];
      const p0={re:a.re + t0*dir.re, im:a.im + t0*dir.im};
      const p1={re:a.re + t1*dir.re, im:a.im + t1*dir.im};
      g.appendChild(svgEl("path",{d:`M ${xToSvg(p0.re)} ${yToSvg(p0.im)} L ${xToSvg(p1.re)} ${yToSvg(p1.im)}`, fill:"none", stroke, "stroke-width":sw, "stroke-linecap":"round", "stroke-dasharray": dashed ? "7 7":"0"}));
      return g;
    }

    if (L.typeId===2){
      const a=L.a, b=L.b;
      const m={re:(a.re+b.re)/2, im:(a.im+b.im)/2};
      const d={re:b.re-a.re, im:b.im-a.im};
      const perp={re:-d.im, im:d.re};
      const n=Math.hypot(perp.re, perp.im);
      if (n<1e-9) return g;
      const dir={re:perp.re/n, im:perp.im/n};
      const seg=lineToBounds(m, dir);
      if (!seg) return g;
      const p0={re:m.re + seg[0]*dir.re, im:m.im + seg[0]*dir.im};
      const p1={re:m.re + seg[1]*dir.re, im:m.im + seg[1]*dir.im};
      g.appendChild(svgEl("path",{d:`M ${xToSvg(p0.re)} ${yToSvg(p0.im)} L ${xToSvg(p1.re)} ${yToSvg(p1.im)}`, fill:"none", stroke, "stroke-width":sw, "stroke-linecap":"round", "stroke-dasharray": dashed ? "7 7":"0"}));
      return g;
    }

    if (L.typeId===3){
      const a=L.a, b=L.b;
      const d={re:b.re-a.re, im:b.im-a.im};
      const n=Math.hypot(d.re,d.im);
      if (n<1e-9) return g;
      const dir={re:d.re/n, im:d.im/n};
      // two rays: from a backwards, from b forwards
      const segA=lineToBounds(a, {re:-dir.re, im:-dir.im});
      const segB=lineToBounds(b, dir);
      if (segA){
        const p0={re:a.re + Math.max(0.001, segA[0])*(-dir.re), im:a.im + Math.max(0.001, segA[0])*(-dir.im)};
        const p1={re:a.re + segA[1]*(-dir.re), im:a.im + segA[1]*(-dir.im)};
        g.appendChild(svgEl("path",{d:`M ${xToSvg(p0.re)} ${yToSvg(p0.im)} L ${xToSvg(p1.re)} ${yToSvg(p1.im)}`, fill:"none", stroke, "stroke-width":sw, "stroke-linecap":"round", "stroke-dasharray": dashed ? "7 7":"0"}));
      }
      if (segB){
        const p0={re:b.re + Math.max(0.001, segB[0])*dir.re, im:b.im + Math.max(0.001, segB[0])*dir.im};
        const p1={re:b.re + segB[1]*dir.re, im:b.im + segB[1]*dir.im};
        g.appendChild(svgEl("path",{d:`M ${xToSvg(p0.re)} ${yToSvg(p0.im)} L ${xToSvg(p1.re)} ${yToSvg(p1.im)}`, fill:"none", stroke, "stroke-width":sw, "stroke-linecap":"round", "stroke-dasharray": dashed ? "7 7":"0"}));
      }
      return g;
    }

    return g;
  }

  function renderDiagram(){
    if (!diagramVisible || !current) return;

    const svg = el.argandSvg;
    svg.innerHTML = "";

    svg.appendChild(svgEl("rect",{x:0,y:0,width:DIAG.W,height:DIAG.H,fill:"#fff"}));
    svg.appendChild(buildGrid());

    if (!reverse){
      // locus (default off)
      if (diagramCfg.showLocus){
        svg.appendChild(locusPath(current.locus, "#f59e0b"));
      }

      // points
      current.options.forEach((z, i) => {
        const ok = current.correct[i];
        if (ok && !diagramCfg.showGoodPts) return;
        if (!ok && !diagramCfg.showBadPts) return;

        const x=xToSvg(z.re), y=yToSvg(z.im);
        svg.appendChild(svgEl("circle",{cx:x, cy:y, r:7, fill:"#fff", stroke: ok ? "#16a34a" : "#dc2626", "stroke-width":2}));
        svg.appendChild(drawTickCross(x,y, ok ? "tick":"cross"));
      });
      return;
    }

    // reverse mode: loci options
    current.loci.forEach((L, i) => {
      const ok = current.correct[i];
      if (ok && !diagramCfg.showGoodLoci) return;
      if (!ok && !diagramCfg.showBadLoci) return;
      svg.appendChild(locusPath(L, ok ? "#16a34a" : "#dc2626", !ok));
    });

    if (diagramCfg.showStar){
      const x=xToSvg(current.z0.re), y=yToSvg(current.z0.im);
      svg.appendChild(drawStar(x,y));
      svg.appendChild(svgEl("circle",{cx:x, cy:y, r:8, fill:"none", stroke:"#111","stroke-width":2, "opacity":0.25}));
    }
  }

  function buildDiagramToggles(){
    const wrap = el.diagramToggles;
    wrap.innerHTML = "";

    function addToggle(id, label, checked){
      const lab=document.createElement("label");
      lab.className="chk";
      const inp=document.createElement("input");
      inp.type="checkbox";
      inp.id=id;
      inp.checked=checked;
      lab.appendChild(inp);
      lab.appendChild(document.createTextNode(" "+label));
      wrap.appendChild(lab);
      return inp;
    }

    if (!reverse){
      const a = addToggle("tgGoodPts", "Correct points (✅)", diagramCfg.showGoodPts);
      const b = addToggle("tgBadPts", "Incorrect points (❌)", diagramCfg.showBadPts);
      const c = addToggle("tgLocus", "Locus", diagramCfg.showLocus);

      a.addEventListener("change", ()=>{ diagramCfg.showGoodPts=a.checked; renderDiagram(); });
      b.addEventListener("change", ()=>{ diagramCfg.showBadPts=b.checked; renderDiagram(); });
      c.addEventListener("change", ()=>{ diagramCfg.showLocus=c.checked; renderDiagram(); });
      return;
    }

    const a = addToggle("tgGoodLoci", "Correct loci (green)", diagramCfg.showGoodLoci);
    const b = addToggle("tgBadLoci", "Incorrect loci (red)", diagramCfg.showBadLoci);
    const c = addToggle("tgStar", "Given point (★)", diagramCfg.showStar);

    a.addEventListener("change", ()=>{ diagramCfg.showGoodLoci=a.checked; renderDiagram(); });
    b.addEventListener("change", ()=>{ diagramCfg.showBadLoci=b.checked; renderDiagram(); });
    c.addEventListener("change", ()=>{ diagramCfg.showStar=c.checked; renderDiagram(); });
  }

  function showDiagram(){
    diagramVisible = true;
    el.diagramPanel.style.display = "block";
    buildDiagramToggles();
    renderDiagram();
  }

// ================== cooldown ==================
  let cooldownTimer=null, cooldownUntil=0;
  function clearCooldown(){
    if (cooldownTimer) clearInterval(cooldownTimer);
    cooldownTimer=null; cooldownUntil=0;
    el.cooldownLbl.textContent="";
    el.checkBtn.disabled=false;
  }
  function startCooldown(seconds=60){
    cooldownUntil = Date.now() + seconds*1000;
    el.checkBtn.disabled=true;
    const tick = () => {
      const left = Math.max(0, Math.ceil((cooldownUntil - Date.now())/1000));
      if (left<=0){ clearCooldown(); return; }
      el.cooldownLbl.textContent = `Check locked for ${left}s after an incorrect answer.`;
    };
    tick();
    cooldownTimer = setInterval(tick, 250);
  }

  function clearRevealStyles(){
    [...el.options.children].forEach(node => node.classList.remove("reveal-good","reveal-bad"));
  }

  // ================== next level control ==================
  let nextUnlocked = false;
  function showNext(){ nextUnlocked = true; el.nextBtn.style.display = ""; el.reviewBtn.style.display = ""; }
  function hideNext(){ nextUnlocked = false; el.nextBtn.style.display = "none"; el.reviewBtn.style.display = "none"; hideDiagram(); }

  // ================== final-option rapid click cheat (still supported) ==================
  // 20 clicks in 2 seconds on the FINAL option reveals + unlocks
  let lastOptClickTimes = [];
  function noteFinalOptionClickAndMaybeReveal(){
    const now = Date.now();
    lastOptClickTimes.push(now);
    lastOptClickTimes = lastOptClickTimes.filter(t => now - t <= 2000);
    if (lastOptClickTimes.length >= 20){
      revealSolution(true);
      lastOptClickTimes = [];
    }
  }

  // ================== locus generation ==================
  function pickTypeForLevel(level){
    // Prefer introducing new types over the first 4 levels, but only from allowedTypes
    const pref = (level===1) ? 0 : (level===2) ? 1 : (level===3) ? 2 : (level===4) ? 3 : null;
    if (pref!==null && allowedTypes.includes(pref)) return pref;
    return choice(allowedTypes);
  }

  function targetCorrectCount(n){
    const t = Math.round(n/2);
    return Math.max(1, Math.min(n-1, t)); // never 0 or n
  }

  function snapHalf(z){ return {re: Math.round(z.re*2)/2, im: Math.round(z.im*2)/2}; }
  function uniqPush(arr, z, used){
    const key = z.re.toFixed(3)+","+z.im.toFixed(3);
    if (used.has(key)) return false;
    used.add(key); arr.push(z); return true;
  }

  // For |z-a|=k we use scaled 3-4-5 triangles:
  // dx = 3s, dy = 4s, k = 5s, with s in {0.5,1,1.5,2,2.5,3}
  const SCALES_345 = [0.5,1,1.5,2,2.5,3];

  function buildLocusType(typeId){
    const a = randomComplex(6,0.5);
    let b=null, k=null, theta=null, thetaTex=null, tex="", checker=null;

    if (typeId===0){
      const s = choice(SCALES_345);
      k = 5*s;
      tex = `\\(\\left|${texZMinus(a)}\\right|=${texNum(k)}\\)`;
      checker = (z) => nearly(norm(sub(z,a)), k, 2e-3);
      return {typeId,a,b,k,theta,thetaTex,tex,checker, scale345:s};
    }

    if (typeId===1){
      const fr = choice(ANGLES);
      theta = angleToRadians(fr);
      thetaTex = angleToTex(fr);
      tex = `\\(\\arg\\left(${texZMinus(a)}\\right)=${thetaTex}\\)`;
      checker = (z) => {
        const v=sub(z,a);
        if (norm(v)<1e-6) return false;
        return Math.abs(wrapPi(arg(v)-theta))<1e-3;
      };
      return {typeId,a,b,k,theta,thetaTex,tex,checker};
    }

    if (typeId===2){
      b = randomNonEqualComplex([a],6,0.5);
      tex = `\\(\\left|${texZMinus(a)}\\right|=\\left|${texZMinus(b)}\\right|\\)`;
      checker = (z) => nearly(norm(sub(z,a)), norm(sub(z,b)), 2e-3);
      return {typeId,a,b,k,theta,thetaTex,tex,checker};
    }

    if (typeId===3){
      b = randomNonEqualComplex([a],6,0.5);
      tex = `\\(\\arg\\left(${texZMinus(a)}\\right)=\\arg\\left(${texZMinus(b)}\\right)\\)`;
      checker = (z) => {
        const v1=sub(z,a), v2=sub(z,b);
        if (norm(v1)<1e-6 || norm(v2)<1e-6) return false;
        return sameArg(v1,v2);
      };
      return {typeId,a,b,k,theta,thetaTex,tex,checker};
    }

    return null;
  }

  // Generate satisfying points
  function genSatisfyingPoints(locus, want){
    const out=[], used=new Set();
    const typeId = locus.typeId;

    if (typeId===0){
      // Use 3-4-5 offsets to guarantee half-grid friendly points
      const s = locus.scale345 ?? choice(SCALES_345);
      const dx = 3*s, dy = 4*s;
      const offs = [
        {x: dx, y: dy},{x: dx, y:-dy},{x:-dx,y: dy},{x:-dx,y:-dy},
        {x: dy, y: dx},{x: dy, y:-dx},{x:-dy,y: dx},{x:-dy,y:-dx}
      ];
      for (let tries=0; tries<4000 && out.length<want; tries++){
        const o = choice(offs);
        const z = snapHalf({re: locus.a.re + o.x, im: locus.a.im + o.y});
        if (locus.checker(z)) uniqPush(out,z,used);
      }
      // top-up with random circle points (less structured)
      const angles = [];
      for (let k=0;k<24;k++) angles.push((2*Math.PI*k)/24);
      for (let tries=0; tries<8000 && out.length<want; tries++){
        const t = choice(angles);
        const z = snapHalf({re:locus.a.re + locus.k*Math.cos(t), im:locus.a.im + locus.k*Math.sin(t)});
        if (locus.checker(z)) uniqPush(out,z,used);
      }
    }

    if (typeId===1){
      const dir = {re: Math.cos(locus.theta), im: Math.sin(locus.theta)};
      const rs = [];
      for (let r=0.5; r<=10; r+=0.5) rs.push(r);
      for (let tries=0; tries<12000 && out.length<want; tries++){
        const r = choice(rs);
        const z = snapHalf(add(locus.a, mulScalar(dir, r)));
        if (locus.checker(z)) uniqPush(out,z,used);
      }
    }

    if (typeId===2){
      const a=locus.a, b=locus.b;
      const m=mulScalar(add(a,b),0.5);
      const d=sub(b,a);
      const perp={re:-d.im, im:d.re};
      const pn=norm(perp);
      if (pn>1e-6){
        const dir=mulScalar(perp, 1/pn);
        const ts=[];
        for (let t=-10; t<=10; t+=0.5) if (Math.abs(t)>0.1) ts.push(t);
        for (let tries=0; tries<20000 && out.length<want; tries++){
          const t=choice(ts);
          const z=snapHalf(add(m, mulScalar(dir,t)));
          if (locus.checker(z)) uniqPush(out,z,used);
        }
      }
    }

    if (typeId===3){
      const a=locus.a, b=locus.b;
      const d=sub(b,a), dn=norm(d);
      if (dn>1e-6){
        const dir=mulScalar(d, 1/dn);
        const ts=[];
        for (let t=0.5; t<=10; t+=0.5) ts.push(t);
        for (let tries=0; tries<24000 && out.length<want; tries++){
          const t=choice(ts);
          const useA = Math.random()<0.5;
          const z = useA ? snapHalf(add(a, mulScalar(dir,-t))) : snapHalf(add(b, mulScalar(dir, +t)));
          if (locus.checker(z)) uniqPush(out,z,used);
        }
      }
    }

    // last-resort top up
    for (let tries=0; tries<60000 && out.length<want; tries++){
      const z=randomComplex(6,0.5);
      if (locus.checker(z)) uniqPush(out,z,used);
    }

    return out;
  }

  function genNonSatisfyingPoints(locus, want){
    const out=[], used=new Set();
    for (let tries=0; tries<80000 && out.length<want; tries++){
      const z=randomComplex(6,0.5);
      if (!locus.checker(z)) uniqPush(out,z,used);
    }
    return out;
  }

  function makeNormalQuestion(level, n){
    const typeId = pickTypeForLevel(level);
    for (let attempt=0; attempt<2500; attempt++){
      const locus = buildLocusType(typeId);
      const tc = targetCorrectCount(n);
      const good = genSatisfyingPoints(locus, tc);
      const bad  = genNonSatisfyingPoints(locus, n-tc);
      if (good.length===tc && bad.length===n-tc){
        const options = shuffle([...good, ...bad]);
        const correct = options.map(locus.checker);
        const count = correct.filter(Boolean).length;
        if (count===tc) return {mode:"normal", level, locus, options, correct, tc};
      }
    }
    // fallback
    const locus=buildLocusType(0);
    const tc=targetCorrectCount(n);
    const options = shuffle([...genSatisfyingPoints(locus, tc).slice(0,tc), ...genNonSatisfyingPoints(locus, n-tc).slice(0,n-tc)]);
    const correct = options.map(locus.checker);
    return {mode:"normal", level, locus, options, correct, tc};
  }

  // Reverse mode: build loci that are true/false for given point
  function buildTrueLocusForPoint(typeId, z0){
    if (typeId===0){
      // force 3-4-5: choose s, choose offset (±3s,±4s) (or swapped), set a = z0 - offset, k=5s
      const s = choice(SCALES_345);
      const dx = 3*s, dy = 4*s;
      const offs = [
        {x: dx, y: dy},{x: dx, y:-dy},{x:-dx,y: dy},{x:-dx,y:-dy},
        {x: dy, y: dx},{x: dy, y:-dx},{x:-dy,y: dx},{x:-dy,y:-dx}
      ];
      const o = choice(offs);
      const a = snapHalf({re: z0.re - o.x, im: z0.im - o.y});
      const k = 5*s;
      const tex = `\\(\\left|${texZMinus(a)}\\right|=${texNum(k)}\\)`;
      const checker = (z) => nearly(norm(sub(z,a)), k, 2e-3);
      return {typeId, a, b:null, k, theta:null, thetaTex:null, tex, checker, scale345:s};
    }

    if (typeId===1){
      const fr = choice(ANGLES);
      const theta = angleToRadians(fr);
      const thetaTex = angleToTex(fr);
      const dir = {re: Math.cos(theta), im: Math.sin(theta)};
      const rs = [];
      for (let r=0.5; r<=10; r+=0.5) rs.push(r);
      for (let tries=0; tries<4000; tries++){
        const r = choice(rs);
        const a = snapHalf(sub(z0, mulScalar(dir,r)));
        if (norm(sub(z0,a))<1e-6) continue;
        const tex = `\\(\\arg\\left(${texZMinus(a)}\\right)=${thetaTex}\\)`;
        const checker = (z) => {
          const v=sub(z,a);
          if (norm(v)<1e-6) return false;
          return Math.abs(wrapPi(arg(v)-theta))<1e-3;
        };
        if (checker(z0)) return {typeId, a, b:null, k:null, theta, thetaTex, tex, checker};
      }
      return buildLocusType(1);
    }

    if (typeId===2){
      const a = randomNonEqualComplex([z0],6,0.5);
      const v = sub(z0,a);
      let b = snapHalf({re: z0.re + v.im, im: z0.im - v.re});
      if (norm(sub(a,b))<1e-6 || norm(sub(z0,b))<1e-6) b = randomNonEqualComplex([a,z0],6,0.5);
      const tex = `\\(\\left|${texZMinus(a)}\\right|=\\left|${texZMinus(b)}\\right|\\)`;
      const checker = (z) => nearly(norm(sub(z,a)), norm(sub(z,b)), 2e-3);
      return {typeId, a, b, k:null, theta:null, thetaTex:null, tex, checker};
    }

    if (typeId===3){
      const fr = choice(ANGLES);
      const theta = angleToRadians(fr);
      const dir = {re: Math.cos(theta), im: Math.sin(theta)};
      const rs=[]; for (let r=0.5;r<=10;r+=0.5) rs.push(r);
      for (let tries=0; tries<12000; tries++){
        const r1=choice(rs), r2=choice(rs);
        if (Math.abs(r1-r2)<1e-9) continue;
        const a=snapHalf(sub(z0, mulScalar(dir,r1)));
        const b=snapHalf(sub(z0, mulScalar(dir,r2)));
        if (norm(sub(a,b))<1e-6) continue;
        if (norm(sub(z0,a))<1e-6 || norm(sub(z0,b))<1e-6) continue;
        const tex = `\\(\\arg\\left(${texZMinus(a)}\\right)=\\arg\\left(${texZMinus(b)}\\right)\\)`;
        const checker = (z) => {
          const v1=sub(z,a), v2=sub(z,b);
          if (norm(v1)<1e-6 || norm(v2)<1e-6) return false;
          return sameArg(v1,v2);
        };
        if (checker(z0)) return {typeId, a, b, k:null, theta:null, thetaTex:null, tex, checker};
      }
      return buildLocusType(3);
    }

    return buildLocusType(0);
  }

  function buildFalseLocusForPoint(typeId, z0){
    for (let tries=0; tries<4000; tries++){
      const L = buildLocusType(typeId);
      if (!L.checker(z0)) return L;
    }
    // forced miss
    if (typeId===0){
      const s = choice(SCALES_345);
      const k = 5*s;
      const a = randomNonEqualComplex([z0],6,0.5);
      const tex = `\\(\\left|${texZMinus(a)}\\right|=${texNum(k)}\\)`;
      const checker = (z) => nearly(norm(sub(z,a)), k, 2e-3);
      return {typeId, a, b:null, k, theta:null, thetaTex:null, tex, checker, scale345:s};
    }
    return buildLocusType(typeId);
  }

  function makeReverseQuestion(level, n){
    for (let attempt=0; attempt<2500; attempt++){
      const z0 = randomComplex(6,0.5);
      const tc = targetCorrectCount(n);

      // choose types, roughly mixed
      const types = [];
      const base = [...allowedTypes];
      shuffle(base);
      for (let i=0;i<Math.min(base.length, n);i++) types.push(base[i]);
      while (types.length<n) types.push(choice(allowedTypes));
      shuffle(types);

      // which indices should be true
      const idxs = [...Array(n).keys()];
      shuffle(idxs);
      const trueSet = new Set(idxs.slice(0,tc));

      const loci = [];
      for (let i=0;i<n;i++){
        const t = types[i];
        loci.push(trueSet.has(i) ? buildTrueLocusForPoint(t,z0) : buildFalseLocusForPoint(t,z0));
      }

      const correct = loci.map(L => L.checker(z0));
      const count = correct.filter(Boolean).length;
      if (count===tc) return {mode:"reverse", level, z0, loci, correct, tc};
    }

    // fallback
    const z0 = randomComplex(6,0.5);
    const tc = targetCorrectCount(n);
    const loci = [];
    for (let i=0;i<n;i++){
      loci.push(i<tc ? buildTrueLocusForPoint(choice(allowedTypes), z0) : buildFalseLocusForPoint(choice(allowedTypes), z0));
    }
    shuffle(loci);
    const correct = loci.map(L => L.checker(z0));
    return {mode:"reverse", level, z0, loci, correct, tc};
  }

  // ================== extra inputs REQUIRED for every level >= 5 ==================
  function showExtraPanel(html, hint){
    el.extraPanel.style.display = "";
    el.extraRow.innerHTML = html;
    el.extraHint.innerHTML = hint || "";
  }
  function hideExtraPanel(){
    el.extraPanel.style.display = "none";
    el.extraRow.innerHTML = "";
    el.extraHint.textContent = "";
  }

  function checkExtraNormal(current){
    const zInput = document.getElementById("zInput");
    if (!zInput) return {ok:true, reason:""};
    const z = parseComplex(zInput.value);
    if (!z) return {ok:false, reason:"Your entered point isn't in a valid a+bi format."};

    const L = current.locus;
    if ((L.typeId===1 || L.typeId===3) && norm(sub(z, L.a)) < 1e-6) return {ok:false, reason:"Your entered point cannot equal a (arg undefined)."};
    if (L.typeId===3 && L.b && norm(sub(z, L.b)) < 1e-6) return {ok:false, reason:"Your entered point cannot equal b (arg undefined)."};
    if (!L.checker(z)) return {ok:false, reason:"Your entered point does not satisfy the locus."};
    return {ok:true, reason:""};
  }

  function checkerFromParsedLocus(p){
    const a=p.a;
    if (p.typeId===0){
      const k=p.k;
      return (z) => nearly(norm(sub(z,a)), k, 2e-3);
    }
    if (p.typeId===1){
      const th=p.k;
      return (z) => {
        const v=sub(z,a);
        if (norm(v)<1e-6) return false;
        return Math.abs(wrapPi(arg(v)-th))<1e-3;
      };
    }
    if (p.typeId===2){
      const b=p.b;
      return (z) => nearly(norm(sub(z,a)), norm(sub(z,b)), 2e-3);
    }
    if (p.typeId===3){
      const b=p.b;
      return (z) => {
        const v1=sub(z,a), v2=sub(z,b);
        if (norm(v1)<1e-6 || norm(v2)<1e-6) return false;
        return sameArg(v1,v2);
      };
    }
    return null;
  }

  function checkExtraReverse(current){
    const locusInput = document.getElementById("locusInput");
    if (!locusInput) return {ok:true, reason:""};
    const parsed = parseLocusString(locusInput.value);
    if (!parsed) return {ok:false, reason:"Your locus is not in the required formats: |z-a|=k, arg(z-a)=k, |z-a|=|z-b|, arg(z-a)=arg(z-b)."};
    if ((parsed.typeId===2 || parsed.typeId===3) && Math.hypot(parsed.a.re-parsed.b.re, parsed.a.im-parsed.b.im) < 1e-6){
      return {ok:false, reason:"In your locus, a and b must be different."};
    }
    const checker = checkerFromParsedLocus(parsed);
    if (!checker) return {ok:false, reason:"Could not interpret your locus."};
    if (!checker(current.z0)) return {ok:false, reason:"Your locus does not contain the given point."};
    if ((parsed.typeId===1 || parsed.typeId===3) && norm(sub(current.z0, parsed.a)) < 1e-6){
      return {ok:false, reason:"Your locus uses arg(z-a) but the point equals a (arg undefined)."};
    }
    if (parsed.typeId===3 && norm(sub(current.z0, parsed.b)) < 1e-6){
      return {ok:false, reason:"Your locus uses arg(z-b) but the point equals b (arg undefined)."};
    }
    return {ok:true, reason:""};
  }

  // ================== app state ==================
  let level = 1;
  let reverse = false;
  let current = null;
  let selected = new Set();
  let attempts = 0;

  // Session settings (locked after the start screen)
  let sessionN = 4;
  let sessionReverse = false;

  // Locus types selected on start screen (subset of 0..3)
  let allowedTypes = [0,1,2,3];

  // Diagram (review) state
  let diagramVisible = false;
  const diagramCfg = {
    // normal mode
    showGoodPts: true,
    showBadPts: false,
    showLocus: false,
    // reverse mode
    showGoodLoci: true,
    showBadLoci: false,
    showStar: true,
  };

  function hideDiagram(){
    diagramVisible = false;
    el.diagramPanel.style.display = "none";
  }

  function revealSolution(unlockNext=false){
    clearRevealStyles();
    const wanted = current.correct.map((ok,i)=> ok?i:null).filter(v=>v!==null);
    [...el.options.children].forEach((node, idx) => {
      if (wanted.includes(idx)) node.classList.add("reveal-good");
      else node.classList.add("reveal-bad");
    });
    const wantedHuman = wanted.map(i=>i+1).join(", ");
    setMsg(`Correct option(s): ${wantedHuman}. Do you need to ask for help before moving on?`, "bad");
    if (unlockNext) showNext();
  }

  function render(){
    reverse = sessionReverse;
    el.modeLbl.textContent = reverse ? "Select locus" : "Select point";
    el.levelLbl.textContent = String(level);

    selected.clear();
    attempts = 0;
    clearCooldown();
    clearRevealStyles();
    hideNext();

    // reset diagram defaults each level
    diagramCfg.showGoodPts = true;
    diagramCfg.showBadPts = false;
    diagramCfg.showLocus = false;
    diagramCfg.showGoodLoci = true;
    diagramCfg.showBadLoci = false;
    diagramCfg.showStar = true;

    lastOptClickTimes = [];

    const n = sessionN;

    if (!reverse){
      current = makeNormalQuestion(level, n);
      el.promptBox.innerHTML = current.locus.tex;
      el.subLine.innerHTML = `Select answer(s), then click <b>Check</b>. (Hold <b>Shift</b> and click Check to reveal.)`;

      el.options.innerHTML = "";
      setGridColumns(current.options.length);

      current.options.forEach((z, idx) => {
        const card=document.createElement("div");
        card.className="opt";
        const tag=document.createElement("div");
        tag.className="tag";
        tag.textContent=String(idx+1);
        const txt=document.createElement("div");
        txt.className="txt";
        txt.innerHTML = `\\(${texZEquals(z)}\\)`;
        card.appendChild(tag); card.appendChild(txt);

        card.addEventListener("click", () => {
          if (idx === current.options.length - 1) noteFinalOptionClickAndMaybeReveal();
          if (card.classList.contains("selected")){ card.classList.remove("selected"); selected.delete(idx); }
          else { card.classList.add("selected"); selected.add(idx); }
          if (!nextUnlocked) setMsg("Select your answer(s).");
        });

        el.options.appendChild(card);
      });

      if (level >= 5){
        showExtraPanel(
          `<label for="zInput">Enter a new point that satisfies the locus (a+bi):</label>
           <input id="zInput" type="text" placeholder="e.g. 1/2+i or 3/2-2i" style="min-width:260px;" />`,
          `This entered point is part of the mark. Use i (not j). Fractions like 3/2 are allowed.`
        );
      } else hideExtraPanel();

      setMsg("Select your answer(s).");
      typeset();
      return;
    }

    // reverse
    current = makeReverseQuestion(level, n);
    el.promptBox.innerHTML = `Given \\(${texZEquals(current.z0)}\\), which loci contain this point?`;
    el.subLine.innerHTML = `Select answer(s), then click <b>Check</b>. (Hold <b>Shift</b> and click Check to reveal.)`;

    el.options.innerHTML = "";
    setGridColumns(current.loci.length);

    current.loci.forEach((L, idx) => {
      const card=document.createElement("div");
      card.className="opt";
      const tag=document.createElement("div");
      tag.className="tag";
      tag.textContent=String(idx+1);
      const txt=document.createElement("div");
      txt.className="txt";
      txt.innerHTML = L.tex;
      card.appendChild(tag); card.appendChild(txt);

      card.addEventListener("click", () => {
        if (idx === current.loci.length - 1) noteFinalOptionClickAndMaybeReveal();
        if (card.classList.contains("selected")){ card.classList.remove("selected"); selected.delete(idx); }
        else { card.classList.add("selected"); selected.add(idx); }
        if (!nextUnlocked) setMsg("Select your answer(s).");
      });

      el.options.appendChild(card);
    });

    if (level >= 5){
      showExtraPanel(
        `<label for="locusInput">Enter a locus satisfied by the point (exact format):</label>
         <input id="locusInput" type="text"
           placeholder="|z-a|=k  or  arg(z-a)=k  or  |z-a|=|z-b|  or  arg(z-a)=arg(z-b)"
           style="min-width:600px; flex:1 1 600px;" />`,
        `Examples (spaces allowed): <span class="mono">|z-2-3i|=5/2</span> &nbsp; <span class="mono">arg(z+1-i)=pi/3</span> &nbsp; <span class="mono">|z-2|=|z+3i|</span> &nbsp; <span class="mono">arg(z-1)=arg(z+2i)</span>.`
      );
    } else hideExtraPanel();

    setMsg("Select your answer(s).");
    typeset();
  }

  function checkAnswer(e){
    if (!current) return;
    if (Date.now() < cooldownUntil) return;

    // SHIFT CHEAT: reveal + unlock next immediately
    if (e && e.shiftKey){
      revealSolution(true);
      return;
    }

    attempts += 1;

    const wanted = current.correct.map((ok,i)=> ok?i:null).filter(v=>v!==null);
    const chosen = [...selected].sort((a,b)=>a-b);
    const same = (chosen.length===wanted.length) && chosen.every((v,i)=>v===wanted[i]);

    let extra = {ok:true, reason:""};
    if (level >= 5){
      extra = reverse ? checkExtraReverse(current) : checkExtraNormal(current);
    }

    if (same && extra.ok){
      clearCooldown();
      clearRevealStyles();
      setMsg("Correct ✅", "good");
      showNext();
      return;
    }

    if (!extra.ok){
      setMsg(extra.reason + " Check is locked for 60 seconds.", "bad");
    } else {
      setMsg("Not quite ❌ Check is locked for 60 seconds.", "bad");
    }

    // after second wrong: reveal + unlock next
    if (attempts >= 2){
      revealSolution(true);
    }

    startCooldown(60);
  }

  // ================== init & events ==================

  // populate start overlay options dropdown 4..30
  (function(){
    const startSel = document.getElementById("startNumOptSel");
    if (!startSel) return;
    for (let k=4; k<=30; k++){
      const opt=document.createElement("option");
      opt.value=String(k);
      opt.textContent=String(k);
      if (k===4) opt.selected=true;
      startSel.appendChild(opt);
    }
  })();

el.checkBtn.addEventListener("click", (e) => checkAnswer(e));

  el.nextBtn.addEventListener("click", (e) => {
    if (!nextUnlocked && !(e && e.shiftKey)) return;
    level += 1;
    render();
  });


  el.reviewBtn.addEventListener("click", () => {
    if (!nextUnlocked) return;
    if (!diagramVisible) showDiagram();
    else hideDiagram();
  });

  el.closeDiagramBtn.addEventListener("click", () => hideDiagram());

  window.addEventListener("resize", () => {
    if (!current) return;
    const n = reverse ? current.loci.length : current.options.length;
    setGridColumns(n);
  });

  // start
  setMsg("Select your answer(s).");

  // Start screen locus selection
  function applyStartSelection(){
    const picks = [...el.startOverlay.querySelectorAll('input[type="checkbox"][data-type]')];
    const chosen = picks.filter(p=>p.checked).map(p=>parseInt(p.getAttribute("data-type"),10));
    if (!chosen.length){
      el.startNote.textContent = "Please select at least one locus type.";
      return false;
    }
    allowedTypes = chosen;

    // apply start options + mode (locked for the session)
    const startNumSel = document.getElementById("startNumOptSel");
    sessionN = parseInt((startNumSel && startNumSel.value) ? startNumSel.value : "4", 10);
    if (!(sessionN>=4 && sessionN<=30)) sessionN = 4;

    const modeVal = (document.querySelector('input[name="startMode"]:checked')||{}).value || "normal";
    sessionReverse = (modeVal === "reverse");

    // reflect locked settings in header pills
    el.numOptLbl.textContent = String(sessionN);
    el.modeLbl.textContent = sessionReverse ? "Select locus" : "Select point";

    el.startNote.textContent = "";
    el.startOverlay.style.display = "none";
    // reset game
    level = 1;
    render();
    return true;
  }

  el.startBtn.addEventListener("click", () => applyStartSelection());

  // typeset overlay maths
  typeset();

  // Do not auto-start; wait for user to choose types
  
})();
</script>
</body>
</html>