<script>
/* Site: https://mrt-maths.github.io/Shared/ */
const OWNER  = "mrt-maths";
const REPO   = "13FM";
const BRANCH = "main";
/* If your games are in a subfolder (e.g. /games), set PATH="games" */
const PATH   = "";

const statusEl = document.getElementById("status");
const gridEl = document.getElementById("games");
const qEl = document.getElementById("q");
const metaEl = document.getElementById("meta");

let allFiles = [];   // [{ name, updatedAt: Date|null, updatedISO: string|null, sha: string|null }]

function prettify(filename){
  return filename
    .replace(/\.html$/i,"")
    .replace(/[-_]+/g," ")
    .replace(/\b\w/g, c => c.toUpperCase());
}

function formatDate(d){
  if(!d) return "Unknown";
  // Uses visitor’s locale/timezone
  return new Intl.DateTimeFormat(undefined, {
    year: "numeric", month: "short", day: "2-digit",
    hour: "2-digit", minute: "2-digit"
  }).format(d);
}

function render(list){
  if (!list.length){
    gridEl.innerHTML = "";
    statusEl.innerHTML = `<div class="error">No matching HTML files found.</div>`;
    metaEl.textContent = "";
    return;
  }
  statusEl.innerHTML = "";
  const base = PATH ? (PATH.replace(/\/+$/,"") + "/") : "";

  gridEl.innerHTML = list.map(f => {
    const updatedLabel = f.updatedAt ? formatDate(f.updatedAt) : "Unknown";
    return `
      <a class="card" href="${base}${encodeURI(f.name)}">
        <div class="title">${prettify(f.name)}</div>
        <div class="desc">${base}${f.name}</div>
        <div class="small" style="margin-top:10px;">Updated: ${updatedLabel}</div>
      </a>
    `;
  }).join("");

  const known = list.filter(x => x.updatedAt).length;
  metaEl.textContent = `${list.length} game(s) • ${known} with update dates`;
}

/** Simple concurrency runner */
async function mapLimit(arr, limit, mapper){
  const results = new Array(arr.length);
  let i = 0;
  const workers = Array.from({length: Math.min(limit, arr.length)}, async () => {
    while(i < arr.length){
      const idx = i++;
      results[idx] = await mapper(arr[idx], idx);
    }
  });
  await Promise.all(workers);
  return results;
}

/** Cache latest commit per file in localStorage */
const CACHE_KEY = `mrt_index_cache:${OWNER}/${REPO}@${BRANCH}:${PATH || "/"}`;
const CACHE_TTL_MS = 6 * 60 * 60 * 1000; // 6 hours

function loadCache(){
  try{
    const raw = localStorage.getItem(CACHE_KEY);
    if(!raw) return null;
    const obj = JSON.parse(raw);
    if(!obj || !obj.savedAt || !obj.data) return null;
    if(Date.now() - obj.savedAt > CACHE_TTL_MS) return null;
    return obj.data; // { [fullPath]: { updatedISO, sha } }
  }catch{ return null; }
}

function saveCache(cacheObj){
  try{
    localStorage.setItem(CACHE_KEY, JSON.stringify({ savedAt: Date.now(), data: cacheObj }));
  }catch{}
}

async function fetchLatestCommitForPath(fullPath, cache){
  // fullPath example: "MyFolder/Game.html" or "Game.html"
  if(cache && cache[fullPath]?.updatedISO){
    return { updatedISO: cache[fullPath].updatedISO, sha: cache[fullPath].sha || null, fromCache: true };
  }

  const commitsApi =
    `https://api.github.com/repos/${OWNER}/${REPO}/commits` +
    `?sha=${encodeURIComponent(BRANCH)}` +
    `&path=${encodeURIComponent(fullPath)}` +
    `&per_page=1`;

  const res = await fetch(commitsApi, { headers: { "Accept": "application/vnd.github+json" }});
  if(!res.ok) throw new Error(`Commits API error ${res.status} for ${fullPath}`);
  const arr = await res.json();
  if(!Array.isArray(arr) || !arr.length) return { updatedISO: null, sha: null, fromCache: false };

  const updatedISO = arr[0]?.commit?.committer?.date || arr[0]?.commit?.author?.date || null;
  const sha = arr[0]?.sha || null;
  return { updatedISO, sha, fromCache: false };
}

async function load(){
  statusEl.innerHTML = `<div class="small">Loading…</div>`;
  gridEl.innerHTML = "";
  metaEl.textContent = "";

  try{
    const api = `https://api.github.com/repos/${OWNER}/${REPO}/contents/${PATH}?ref=${encodeURIComponent(BRANCH)}`;
    const res = await fetch(api, { headers: { "Accept": "application/vnd.github+json" }});
    if(!res.ok){
      throw new Error(`GitHub API error ${res.status}. Check OWNER/REPO/BRANCH/PATH and that the repo is public.`);
    }
    const items = await res.json();

    const names = items
      .filter(x => x.type === "file" && /\.html$/i.test(x.name))
      .map(x => x.name)
      .filter(n => n.toLowerCase() !== "index.html");

    if(!names.length){
      statusEl.innerHTML = `<div class="error">No other .html files found in this folder. If they’re in a subfolder, set PATH to that folder name.</div>`;
      return;
    }

    // Prepare cache + full paths
    const cache = loadCache() || {};
    const base = PATH ? (PATH.replace(/\/+$/,"") + "/") : "";

    statusEl.innerHTML = `<div class="small">Fetching last-updated times… (this may take a moment)</div>`;

    let done = 0;
    const enriched = await mapLimit(names, 5, async (name) => {
      const fullPath = `${base}${name}`;
      try{
        const { updatedISO, sha, fromCache } = await fetchLatestCommitForPath(fullPath, cache);
        if(updatedISO && !fromCache){
          cache[fullPath] = { updatedISO, sha };
        }
        return {
          name,
          updatedISO: updatedISO || null,
          updatedAt: updatedISO ? new Date(updatedISO) : null,
          sha: sha || null
        };
      } finally {
        done++;
        statusEl.innerHTML = `<div class="small">Fetching last-updated times… ${done}/${names.length}</div>`;
      }
    });

    saveCache(cache);

    // Sort by most recent updatedAt (unknown dates at bottom)
    enriched.sort((a,b) => {
      const ta = a.updatedAt ? a.updatedAt.getTime() : -Infinity;
      const tb = b.updatedAt ? b.updatedAt.getTime() : -Infinity;
      return tb - ta;
    });

    allFiles = enriched;
    statusEl.innerHTML = "";

    render(allFiles);
  } catch(err){
    statusEl.innerHTML = `<div class="error"><b>Couldn’t load game list.</b><br>${err.message}</div>`;
  }
}

qEl.addEventListener("input", () => {
  const term = qEl.value.trim().toLowerCase();
  const filtered = allFiles.filter(f => f.name.toLowerCase().includes(term));
  render(filtered);
});

document.getElementById("reload").addEventListener("click", () => {
  // Force refresh by clearing cache for this view
  try{ localStorage.removeItem(CACHE_KEY); }catch{}
  load();
});

load();
</script>
