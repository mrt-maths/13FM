<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Numerical Integration Drag-and-Drop Game</title>

  <!-- MathJax -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
      options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    :root{
      --bg:#0b1020;
      --ink:#eef2ff;
      --muted:#b7c0ff;
      --line:rgba(255,255,255,.14);
      --good:#35d07f;
      --bad:#ff4d4d;
      --warn:#ffcc66;
      --accent:#6aa3ff;
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --radius: 16px;
      --slotW: 104px;
      --slotH: 36px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 600px at 20% -10%, rgba(106,163,255,.28), transparent 60%),
                  radial-gradient(900px 500px at 80% 0%, rgba(53,208,127,.18), transparent 60%),
                  var(--bg);
      color: var(--ink);
    }

    /* Sticky header: integral always visible */
    .topbar{
      position: sticky;
      top: 0;
      z-index: 50;
      backdrop-filter: blur(10px);
      background: rgba(11,16,32,.86);
      border-bottom: 1px solid var(--line);
    }
    .topbarInner{
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px 14px 10px;
      display:flex;
      flex-wrap:wrap;
      gap: 10px 14px;
      align-items: center;
      justify-content: space-between;
    }
    .brand{
      display:flex;
      flex-direction:column;
      gap: 4px;
      min-width: 260px;
      flex: 1 1 320px;
    }
    .brand .title{
      font-size: 15px;
      font-weight: 900;
      margin:0;
      letter-spacing:.2px;
    }
    .integralLine{
      font-size: 16px;
      line-height: 1.4;
      color: var(--ink);
      overflow-x:auto;
      white-space: nowrap;
    }

    .controls{
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content:flex-end;
      flex: 0 0 auto;
    }

    select, button, input{
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(17,26,51,.75);
      color: var(--ink);
      padding: 10px 12px;
      font-size: 14px;
      outline: none;
    }
    button{
      cursor:pointer;
      font-weight: 900;
      background: linear-gradient(180deg, rgba(106,163,255,.22), rgba(106,163,255,.10));
      border-color: rgba(106,163,255,.45);
    }
    button.secondary{
      background: rgba(255,255,255,.05);
      border-color: var(--line);
      font-weight: 900;
    }

    .setupInfo{
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 14px 10px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .pill{
      padding: 6px 10px;
      border: 1px solid var(--line);
      border-radius: 999px;
      background: rgba(255,255,255,.05);
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }

    .page{
      max-width: 1200px;
      margin: 0 auto;
      padding: 14px 14px 32px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .card .hd{
      padding: 14px 14px 10px;
      border-bottom: 1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .card .hd .title{
      font-weight: 900;
      font-size: 14px;
      letter-spacing:.2px;
      margin:0;
    }
    .card .bd{ padding: 14px; }

    .stepTag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-weight: 900;
      font-size: 13px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.05);
      margin-bottom: 10px;
    }
    .dot{
      width:10px;height:10px;border-radius:999px;
      background: rgba(255,255,255,.28);
      border:1px solid rgba(255,255,255,.25);
    }
    .dot.good{ background: rgba(53,208,127,.95); border-color: rgba(53,208,127,.8); }
    .dot.lock{ background: rgba(255,204,102,.95); border-color: rgba(255,204,102,.85); }

    .msg{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.16);
      color: var(--ink);
      font-size: 13px;
      line-height: 1.35;
    }
    .msg.good{ border-color: rgba(53,208,127,.5); }
    .msg.bad{ border-color: rgba(255,77,77,.5); }
    .msg.warn{ border-color: rgba(255,204,102,.55); }
    .hidden{ display:none !important; }

    .bank{
      padding: 10px;
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,.18);
      background: rgba(0,0,0,.14);
      min-height: 98px;
    }
    .bank .lbl{
      font-weight: 900;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .tokens{
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: flex-start;
    }
    .token{
      user-select: none;
      -webkit-user-select:none;
      touch-action: none;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.07);
      font-weight: 900;
      font-size: 13px;
      cursor: grab;
      box-shadow: 0 8px 18px rgba(0,0,0,.18);
      white-space: nowrap;
    }
    .token.x{ border-color: rgba(106,163,255,.5); }
    .token.y{ border-color: rgba(53,208,127,.5); }
    .token.small{ font-size: 12px; padding: 6px 9px; }
    .token.used{
      opacity: .25;
      pointer-events: none;
      filter: grayscale(.2);
    }
    .token.ghost{
      position: fixed;
      pointer-events: none;
      opacity: .95;
      z-index: 9999;
      transform: translate(-50%,-50%);
      cursor: grabbing;
    }

    /* Horizontal table */
    .hTableWrap{
      border: 1px solid var(--line);
      border-radius: 16px;
      background: rgba(17,26,51,.45);
      overflow-x: auto;
      padding: 10px;
    }
    .hTable{
      min-width: 720px;
      display:grid;
      grid-template-rows: auto auto auto;
      gap: 10px;
    }
    .hRow{
      display:flex;
      gap: 10px;
      align-items: center;
      justify-content: flex-start;
    }
    .hLabel{
      width: 90px;
      flex: 0 0 auto;
      font-weight: 900;
      color: var(--muted);
      font-size: 13px;
      text-align: right;
      padding-right: 6px;
      white-space: nowrap;
    }
    .hCell{
      display:flex;
      flex-direction:column;
      gap: 6px;
      align-items:center;
      justify-content:center;
      min-width: 112px;
      padding: 6px 6px 4px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.10);
    }
    .idxTag{
      font-size: 12px;
      color: var(--muted);
      font-weight: 900;
      line-height: 1;
      white-space: nowrap;
    }

    .slot, .fSlot{
      width: var(--slotW);
      height: var(--slotH);
      border-radius: 12px;
      border: 1px dashed rgba(255,255,255,.22);
      background: rgba(0,0,0,.12);
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .slot.filled, .fSlot.filled{
      border-style: solid;
      background: rgba(255,255,255,.06);
    }
    .slot.ok, .fSlot.ok{ border-color: rgba(53,208,127,.75); }
    .slot.bad, .fSlot.bad{ border-color: rgba(255,77,77,.75); }

    .row{
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      align-items:center;
      justify-content: center;
      margin-top: 10px;
    }
    .row input[type="text"]{ width: 240px; }

    .formulaArea{
      border-radius: 16px;
      border: 1px solid var(--line);
      background: rgba(17,26,51,.45);
      padding: 12px 12px;
      overflow-x:auto;
      max-width: 980px;
      margin: 0 auto;
    }
    .formulaLead{
      width: 100%;
      text-align: center;
      color: var(--muted);
      font-weight: 900;
      font-size: 13px;
      padding: 2px 0 8px;
      white-space: normal;
    }
    .formulaGiven{
      width: 100%;
      text-align: center;
      color: var(--ink);
      font-weight: 900;
      font-size: 14px;
      padding: 4px 0 10px;
      white-space: normal;
    }
    .formulaLine{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
      font-size: 16px;
      line-height: 1.8;
      padding: 6px 0;
      justify-content: center;
      white-space: nowrap; /* avoids ugly wraps */
    }

    .lockOverlay{
      opacity: .55;
      filter: grayscale(.2);
      pointer-events: none;
    }
    .tiny{ font-size: 12px; color: var(--muted); }
    .mjWarn{ display:none; }
  </style>
</head>

<body>

<div class="topbar">
  <div class="topbarInner">
    <div class="brand">
      <p class="title">Numerical Integration Game</p>
      <div class="integralLine" id="integralDisplay">Loading…</div>
    </div>

    <div class="controls">
      <label class="tiny"><strong>Rule</strong></label>
      <select id="ruleSelect">
        <option value="trapezium">Trapezium rule</option>
        <option value="mid">Mid-ordinate rule</option>
        <option value="simpson">Simpson's rule</option>
      </select>
      <button id="btnNew">New integral</button>
      <button class="secondary" id="btnFullscreen">Fullscreen</button>
    </div>
  </div>

  <div class="setupInfo" id="setupInfo"></div>
</div>

<div class="page">
  <div class="msg warn mjWarn" id="mjWarn">
    If the maths looks unformatted, your device may be blocking MathJax’s CDN.
  </div>

  <!-- STEP 0 -->
  <div class="card" id="panel0">
    <div class="hd"><p class="title">Step 0 — Calculate \(h\)</p></div>
    <div class="bd">
      <div class="stepTag"><span class="dot lock" id="dot0"></span> Step 0 — Find the step size</div>
      <div class="msg" style="margin-top:0;">
        Compute \(h=\dfrac{b-a}{n}\) and enter it <strong>correct to 3 d.p.</strong>
      </div>
      <div class="row">
        <label class="tiny"><strong>Enter \(h\)</strong> (3 d.p.):</label>
        <input type="text" id="hBox" placeholder="e.g. 0.124" />
        <button id="btnCheck0">Check \(h\)</button>
      </div>
      <div class="msg hidden" id="msg0"></div>
    </div>
  </div>

  <!-- STEP 1 -->
  <div class="card" id="panel1">
    <div class="hd"><p class="title">Step 1 — Complete the table</p></div>
    <div class="bd" id="step1Wrap">
      <div class="stepTag"><span class="dot lock" id="dot1"></span> Step 1 — Drag \(x\) and \(y\)</div>

      <div class="bank" id="bankWrap">
        <div class="lbl">Values</div>
        <div class="tokens" id="mixedBank"></div>
      </div>

      <div class="hTableWrap" style="margin-top:10px;">
        <div class="hTable" id="hTable"></div>
      </div>

      <div class="row">
        <button id="btnCheck1">Check table</button>
        <button class="secondary" id="btnReset1">Reset table</button>
      </div>
      <div class="msg hidden" id="msg1"></div>
    </div>
  </div>

  <!-- STEP 2 -->
  <div class="card" id="panel2">
    <div class="hd"><p class="title">Step 2 — Build the formula</p></div>
    <div class="bd" id="step2Wrap">
      <div class="stepTag"><span class="dot lock" id="dot2"></span> Step 2 — Drag into the formula</div>

      <div class="formulaArea">
        <div class="formulaLead" id="whereLine">where \(h=\dfrac{b-a}{n}\)</div>
        <div class="formulaGiven" id="givenFormula">Loading formula…</div>
        <div id="formulaArea"></div>
      </div>

      <div class="row">
        <button id="btnCheck2">Check formula</button>
        <button class="secondary" id="btnReset2">Reset formula</button>
      </div>
      <div class="msg hidden" id="msg2"></div>
    </div>
  </div>

  <!-- STEP 3 -->
  <div class="card" id="panel3">
    <div class="hd"><p class="title">Step 3 — Final answer</p></div>
    <div class="bd" id="step3Wrap">
      <div class="stepTag"><span class="dot lock" id="dot3"></span> Step 3 — Approximate the integral</div>
      <div class="msg" style="margin-top:0;">
        Use the <strong>rounded values in the table</strong>.
      </div>
      <div class="row">
        <label class="tiny"><strong>Approximation:</strong></label>
        <input type="text" id="answerBox" placeholder="e.g. 1.234" />
        <button id="btnCheck3">Check answer</button>
      </div>
      <div class="msg hidden" id="resultBox"></div>
    </div>
  </div>
</div>

<script>
/* =========================
   Dragging (fix "ghosting"/duplication)
   - Only one ghost at a time
   - Guaranteed cleanup on window pointerup/blur
   - Bank tokens become "used" (disabled) once placed
   ========================= */
let dragState = null;

function cleanupDrag(){
  if(!dragState) return;
  try{ dragState.ghostEl?.remove(); }catch(e){}
  dragState = null;
}
window.addEventListener('pointerup', cleanupDrag, true);
window.addEventListener('pointercancel', cleanupDrag, true);
window.addEventListener('blur', cleanupDrag);

function makeDraggable(el){
  el.addEventListener('pointerdown',(ev)=>{
    if(ev.button!==undefined && ev.button!==0) return;
    ev.preventDefault();

    // if something went wrong previously, kill old ghost
    cleanupDrag();

    const tokenId = el.dataset.tokenId;
    const tokenType = el.dataset.type;
    if(!tokenId) return;

    const ghost = el.cloneNode(true);
    ghost.classList.add('ghost');
    ghost.classList.remove('used');
    document.body.appendChild(ghost);

    dragState = { tokenId, tokenType, ghostEl: ghost };
    moveGhost(ev.clientX, ev.clientY);
    el.setPointerCapture?.(ev.pointerId);
  });

  el.addEventListener('pointermove',(ev)=>{
    if(!dragState) return;
    moveGhost(ev.clientX, ev.clientY);
  });

  el.addEventListener('pointerup',(ev)=>{
    if(!dragState) return;
    const dropTarget = droppableUnder(ev.clientX, ev.clientY);
    if(dropTarget){
      handleDropOn(dropTarget, dragState.tokenId, dragState.tokenType);
    }
    cleanupDrag();
  });

  el.addEventListener('pointercancel', cleanupDrag);
}
function moveGhost(x,y){
  if(!dragState) return;
  dragState.ghostEl.style.left = x+'px';
  dragState.ghostEl.style.top  = y+'px';
}
function droppableUnder(x,y){
  const el = document.elementFromPoint(x,y);
  return el ? el.closest('.slot,.fSlot') : null;
}

/* =========================
   State
   ========================= */
const state={
  rule:'trapezium',
  f:null,
  fLatex:'',
  a:0,b:0,h:0,n:0,
  xs:[], ys:[],
  tokens:new Map(),             // tokenId -> {type,label,isRed}
  bankEls:new Map(),            // tokenId -> DOM element in bank
  tableSlots:new Map(),         // slotId -> tokenId
  formulaSlots:new Map(),       // slotId -> tokenId
  correctTable:new Map(),
  correctFormula:new Map(),
  hOk:false,
  tableComplete:false,
  formulaComplete:false,
  approxValueRounded:null,
  trueValue:null
};
const $=(id)=>document.getElementById(id);

/* =========================
   Utility
   ========================= */
function rnd(min,max){ return min+Math.random()*(max-min); }
function choice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function to3(x){ let v=Math.round(x*1000)/1000; if(Object.is(v,-0)) v=0; return v; }
function fmt3(x){ return to3(x).toFixed(3); }
function clamp(x,lo,hi){ return Math.min(hi, Math.max(lo,x)); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

/* minimal-brackets helpers */
function needsParens(expr){
  // needs parentheses if it contains + or - not at start
  for(let i=1;i<expr.length;i++){
    const ch=expr[i];
    if(ch==='+' || ch==='-') return true;
  }
  return false;
}
function wrap(expr){ return needsParens(expr) ? `\\left(${expr}\\right)` : expr; }
function niceCoef(c){
  if(c===1) return '';
  if(c===-1) return '-';
  return String(c);
}
function signJoin(a,bLatex){
  // a is number coef; bLatex is expression
  if(a===0) return '0';
  if(a===1) return bLatex;
  if(a===-1) return `-${wrap(bLatex)}`;
  return `${a}${wrap(bLatex)}`;
}
function simplifyLinear(k,c){
  // return latex string for kx+c with small simplifications (1x -> x, -1x -> -x, 0.5x etc)
  let part = '';
  if(k===0) part = '0';
  else if(k===1) part = 'x';
  else if(k===-1) part = '-x';
  else part = `${k}x`;

  if(c===0) return part;
  if(part==='0') return String(c);
  return `${part}${c>0?'+':'-'}${Math.abs(c)}`;
}
function simplifyPow(p){
  return p===1 ? '' : `^{${p}}`;
}

/* =========================
   Base functions (latex already simplified: no ^1)
   ========================= */
function makeBaseFunction(kind){
  if(kind==='expPow'){
    const a=choice([0.5,0.8,1.2,-0.7,-1.1]);
    const p=choice([1,2,3]);
    const xp = p===1 ? 'x' : `x^{${p}}`;
    return { f:(x)=>Math.exp(a*Math.pow(x,p)), latex:`e^{${a}${xp}}` };
  }
  if(kind==='sin'){
    const a=choice([0.5,1,1.5,2,3]);
    return { f:(x)=>Math.sin(a*x), latex:`\\sin(${a}x)` };
  }
  if(kind==='cos'){
    const a=choice([0.5,1,2,3]);
    return { f:(x)=>Math.cos(a*x), latex:`\\cos(${a}x)` };
  }
  if(kind==='ln'){
    const a=choice([0.5,1,1.5,2,-0.5,-1]);
    return { f:(x)=>Math.log(5+a*x), latex:`\\ln(5+${a}x)` };
  }
  if(kind==='polyExp'){
    const k=choice([1,2,3]);
    const a=choice([0.5,-0.5,0.8,-0.8,1.2]);
    const xk = k===1 ? 'x' : `x^{${k}}`;
    return { f:(x)=>Math.pow(x,k)*Math.exp(a*x), latex:`${xk}e^{${a}x}` };
  }
  // tanSafe
  const a=choice([0.5,1,1.5]);
  return { f:(x)=>Math.tan(a*x), latex:`\\tan(${a}x)` };
}

/* apply x -> (kx+c) (with simplification), plus outer linear A*...+D */
function transform(base){
  const A=choice([1,1,-1,2,0.5,1.5]);
  const D=choice([0,0,0,0.5,-0.5,1,-1]);
  const B=choice([0.5,1,1,1.5,2,-0.5,-1,-2]); // allow negatives too
  const C=choice([0,0,0.25,-0.25,0.5,-0.5]);

  const comp=(x)=>A*base.f(B*x+C)+D;

  const arg = simplifyLinear(B,C);
  const core = base.latex.replace(/x/g, needsParens(arg) ? `(${arg})` : arg);

  let expr = core;
  if(A===-1) expr = `-${wrap(expr)}`;
  else if(A!==1) expr = `${A}${wrap(expr)}`;
  if(D!==0) expr = `${wrap(expr)}${D>0?'+':'-'}${Math.abs(D)}`;

  return { f:comp, latex:expr };
}

/* Combine TWO transformed functions:
   - product: f(x) × g(x)
   - linear combo: a f(x) + b g(x)
*/
function buildCombinedFunction(){
  const kinds=['expPow','sin','ln','cos','polyExp','tanSafe'];
  let k1=choice(kinds), k2=choice(kinds);
  while(k2===k1) k2=choice(kinds);

  const t1=transform(makeBaseFunction(k1));
  const t2=transform(makeBaseFunction(k2));

  const mode = choice(['prod','lin']); // product or linear combination

  if(mode==='prod'){
    return {
      f:(x)=>t1.f(x)*t2.f(x),
      latex:`${wrap(t1.latex)}\\,\\times\\,${wrap(t2.latex)}`,
      mode
    };
  }

  // linear combo af + bg
  const a = choice([-2,-1,-0.5,0.5,1,2]);
  let b = choice([-2,-1,-0.5,0.5,1,2]);
  // avoid both same sign/zero-ish monotony sometimes? keep as-is but avoid a=b=0
  if(a===0 && b===0) b=1;

  const f=(x)=>a*t1.f(x)+b*t2.f(x);

  const Aterm = signJoin(a, t1.latex);
  const Bterm = signJoin(Math.abs(b), t2.latex);
  const latex = `${Aterm}${b>=0?'+':'-'}${Bterm}`;

  return { f, latex, mode };
}

/* =========================
   Grid + integration
   - h now can be "awkward" (e.g. 0.124, 0.035)
   ========================= */
function pickGrid(rule, fInfo){
  // include awkward 3dp options
  const hChoices = [
    0.035,0.041,0.062,0.073,0.083,0.095,
    0.124,0.137,0.148,0.157,0.163,0.175,
    0.204,0.212,0.225,0.238,0.250,0.275,
    0.100,0.125,0.200,0.300
  ];
  let h = to3(choice(hChoices));

  let nMax=(rule==='mid')?8:7;
  if(rule==='simpson') nMax=8;

  let n=Math.floor(rnd(2,nMax+1));
  if(rule==='simpson' && (n%2===1)) n+=1;
  n=clamp(n,2,nMax);
  if(rule==='simpson' && (n%2===1)) n=n-1;

  let a=to3(rnd(-1.2,1.2));
  let b=to3(a+n*h);

  const safeCheck=(a0,b0)=>{
    const sample=90;
    for(let i=0;i<=sample;i++){
      const x=a0+(b0-a0)*i/sample;
      const y=fInfo.f(x);
      if(!Number.isFinite(y)) return false;
      if(Math.abs(y)>1e6) return false;
    }
    return true;
  };

  let tries=0;
  while(tries<220 && !safeCheck(a,b)){
    a=to3(rnd(-1.0,1.0));
    b=to3(a+n*h);
    tries++;
  }
  return {a,b,h,n};
}

function trueIntegralSimpson(f,a,b){
  const N=6000;
  const h=(b-a)/N;
  let s=f(a)+f(b);
  for(let i=1;i<N;i++){
    const x=a+i*h;
    s += (i%2===0?2:4)*f(x);
  }
  return s*h/3;
}

function approxByRuleUsingRounded(rule, ysRounded, hRounded){
  const h=hRounded;
  if(rule==='trapezium'){
    let sum=ysRounded[0]+ysRounded[ysRounded.length-1];
    for(let i=1;i<ysRounded.length-1;i++) sum += 2*ysRounded[i];
    return (h/2)*sum;
  }
  if(rule==='simpson'){
    let s=ysRounded[0]+ysRounded[ysRounded.length-1];
    for(let i=1;i<ysRounded.length-1;i++){
      s += (i%2===1?4:2)*ysRounded[i];
    }
    return (h/3)*s;
  }
  let s=0; for(const y of ysRounded) s+=y;
  return h*s;
}

/* =========================
   Build question
   ========================= */
function buildQuestion(rule){
  state.rule=rule;

  const fInfo=buildCombinedFunction();
  state.f=fInfo.f;
  state.fLatex=fInfo.latex;

  const grid=pickGrid(rule, fInfo);
  state.a=grid.a; state.b=grid.b; state.h=grid.h; state.n=grid.n;

  const xs=[], ys=[];
  if(rule==='mid'){
    for(let i=0;i<state.n;i++){
      const x=to3(state.a+(i+0.5)*state.h);
      xs.push(x);
      ys.push(to3(state.f(x)));
    }
  } else {
    for(let i=0;i<=state.n;i++){
      const x=to3(state.a+i*state.h);
      xs.push(x);
      ys.push(to3(state.f(x)));
    }
  }
  state.xs=xs; state.ys=ys;

  state.approxValueRounded=approxByRuleUsingRounded(rule, ys, state.h);
  state.trueValue=trueIntegralSimpson(state.f, state.a, state.b);

  // reset progress
  state.tokens.clear();
  state.bankEls.clear();
  state.tableSlots.clear();
  state.formulaSlots.clear();
  state.correctTable.clear();
  state.correctFormula.clear();
  state.hOk=false;
  state.tableComplete=false;
  state.formulaComplete=false;

  buildBanksMixed();
  buildTableMappings();
  buildFormulaMappings();

  renderAll();
  clearMessages();
  updateLocks();
  rerenderMath();
}

/* =========================
   Mixed bank (+ red herrings)
   ========================= */
function buildBanksMixed(){
  const needX=state.xs.length;
  const needY=state.ys.length;
  const extra=Math.max(4, Math.round((needX+needY)*0.55));

  let id=1;
  for(const x of state.xs){
    state.tokens.set(`x${id++}`, {type:'x', label:fmt3(x), isRed:false});
  }
  for(const y of state.ys){
    state.tokens.set(`y${id++}`, {type:'y', label:fmt3(y), isRed:false});
  }

  const reqX=new Set(state.xs.map(v=>fmt3(v)));
  const reqY=new Set(state.ys.map(v=>fmt3(v)));

  for(let k=0;k<extra;k++){
    const makeX = Math.random()<0.5;
    if(makeX){
      let x, tries=0;
      const span=state.b-state.a;
      do{
        x=to3(rnd(state.a-0.35*span, state.b+0.35*span));
        tries++;
      }while(tries<80 && reqX.has(fmt3(x)));
      state.tokens.set(`x${id++}`, {type:'x', label:fmt3(x), isRed:true});
    }else{
      const pickX=choice(state.xs);
      const yTrue=state.f(pickX);
      const noise=rnd(-0.8,0.8)*(Math.random()<0.7?1:0.35);
      let y=to3(yTrue+noise);
      let tries=0;
      while(tries<80 && reqY.has(fmt3(y))){
        y=to3(y+rnd(0.12,0.5));
        tries++;
      }
      state.tokens.set(`y${id++}`, {type:'y', label:fmt3(y), isRed:true});
    }
  }
}

function findTokenId(type, label, nonRedOnly){
  for(const [id,tok] of state.tokens.entries()){
    if(tok.type!==type) continue;
    if(nonRedOnly && tok.isRed) continue;
    if(tok.label===label) return id;
  }
  for(const [id,tok] of state.tokens.entries()){
    if(tok.type===type && tok.label===label) return id;
  }
  return null;
}

function buildTableMappings(){
  const cols=state.xs.length;
  for(let c=0;c<cols;c++){
    state.correctTable.set(`t_x_${c}`, findTokenId('x', fmt3(state.xs[c]), true));
    state.correctTable.set(`t_y_${c}`, findTokenId('y', fmt3(state.ys[c]), true));
  }
}

function buildFormulaMappings(){
  if(state.rule==='mid'){
    for(let i=0;i<state.ys.length;i++){
      state.correctFormula.set(`f_mid_${i}`, findTokenId('y', fmt3(state.ys[i]), true));
    }
    return;
  }
  if(state.rule==='trapezium'){
    state.correctFormula.set('f_trap_y0', findTokenId('y', fmt3(state.ys[0]), true));
    state.correctFormula.set('f_trap_yn', findTokenId('y', fmt3(state.ys[state.ys.length-1]), true));
    for(let i=1;i<state.ys.length-1;i++){
      state.correctFormula.set(`f_trap_mid_${i}`, findTokenId('y', fmt3(state.ys[i]), true));
    }
    return;
  }
  state.correctFormula.set('f_simp_y0', findTokenId('y', fmt3(state.ys[0]), true));
  state.correctFormula.set('f_simp_yn', findTokenId('y', fmt3(state.ys[state.ys.length-1]), true));
  for(let i=1;i<state.ys.length-1;i++){
    const key=(i%2===1)?`f_simp_odd_${i}`:`f_simp_even_${i}`;
    state.correctFormula.set(key, findTokenId('y', fmt3(state.ys[i]), true));
  }
}

/* =========================
   Rendering
   ========================= */
function renderAll(){
  renderTopBar();
  renderMixedBank();
  renderHorizontalTable();
  renderFormula();
  refreshBankUsedStates();
}

function renderTopBar(){
  const a=fmt3(state.a), b=fmt3(state.b);
  $('integralDisplay').innerHTML = `\\(\\int_{${a}}^{${b}} ${wrap(state.fLatex)}\\,dx\\)`;

  const ruleName = state.rule==='trapezium' ? 'Trapezium' : state.rule==='mid' ? 'Mid-ordinate' : "Simpson's";
  const numOrdinates = state.xs.length;
  $('setupInfo').innerHTML = `
    <span class="pill"><strong>Rule:</strong> ${ruleName}</span>
    <span class="pill"><strong>Number of strips:</strong> ${state.n}</span>
    <span class="pill"><strong>Number of ordinates:</strong> ${numOrdinates}</span>
    <span class="pill"><strong>a:</strong> ${a}</span>
    <span class="pill"><strong>b:</strong> ${b}</span>
  `;
}

function renderMixedBank(){
  const items=[];
  for(const [id,tok] of state.tokens.entries()) items.push([id,tok]);
  shuffle(items);

  const bank=$('mixedBank');
  bank.innerHTML='';
  state.bankEls.clear();

  for(const [id,tok] of items){
    const el=document.createElement('div');
    el.className=`token ${tok.type}`;
    el.textContent=tok.label;
    el.dataset.tokenId=id;
    el.dataset.type=tok.type;
    makeDraggable(el);
    bank.appendChild(el);
    state.bankEls.set(id, el);
  }
}

function renderHorizontalTable(){
  const cols = state.xs.length;
  const mid = (state.rule==='mid');

  const wrapEl=$('hTable');
  wrapEl.innerHTML='';

  const idxs=[];
  for(let i=0;i<cols;i++){
    idxs.push(mid ? `\\(${i}+\\tfrac12\\)` : `\\(${i}\\)`);
  }

  const r0=document.createElement('div');
  r0.className='hRow';
  r0.innerHTML=`<div class="hLabel">Index</div>`;
  for(let c=0;c<cols;c++){
    const cell=document.createElement('div');
    cell.className='hCell';
    cell.innerHTML=`<div class="idxTag">${idxs[c]}</div>`;
    r0.appendChild(cell);
  }
  wrapEl.appendChild(r0);

  const r1=document.createElement('div');
  r1.className='hRow';
  r1.innerHTML=`<div class="hLabel">\\(${mid?'x_{i+\\tfrac12}':'x_i'}\\)</div>`;
  for(let c=0;c<cols;c++){
    const cell=document.createElement('div');
    cell.className='hCell';
    cell.innerHTML=`<div class="slot" data-slot-id="t_x_${c}" data-accept="x"></div>`;
    r1.appendChild(cell);
  }
  wrapEl.appendChild(r1);

  const r2=document.createElement('div');
  r2.className='hRow';
  r2.innerHTML=`<div class="hLabel">\\(${mid?'y_{i+\\tfrac12}':'y_i'}\\)</div>`;
  for(let c=0;c<cols;c++){
    const cell=document.createElement('div');
    cell.className='hCell';
    cell.innerHTML=`<div class="slot" data-slot-id="t_y_${c}" data-accept="y"></div>`;
    r2.appendChild(cell);
  }
  wrapEl.appendChild(r2);

  document.querySelectorAll('.slot').forEach(slot=>{
    slot.addEventListener('click', ()=> clearSlot(slot));
  });

  redrawPlaced();
}

function buildGivenFormulaLatex(){
  const n = state.n;
  if(state.rule==='mid'){
    const terms=[];
    for(let i=0;i<n;i++){
      const idx = i===0 ? `\\tfrac12` : `${i}+\\tfrac12`;
      terms.push(`y_{${idx}}`);
    }
    return `\\(\\int_a^b y\\,dx \\approx h\\left(${terms.join('+')}\\right)\\)`;
  }

  if(state.rule==='trapezium'){
    const mids=[];
    for(let i=1;i<=n-1;i++) mids.push(`y_{${i}}`);
    return `\\(\\int_a^b y\\,dx \\approx \\frac{h}{2}\\left\\{(y_0+y_${n})+2\\left(${mids.join('+')}\\right)\\right\\}\\)`;
  }

  const odds=[], evens=[];
  for(let i=1;i<=n-1;i++){
    (i%2===1 ? odds : evens).push(`y_{${i}}`);
  }
  return `\\(\\int_a^b y\\,dx \\approx \\frac{h}{3}\\left[(y_0+y_${n})+4\\left(${odds.join('+')}\\right)+2\\left(${evens.join('+')}\\right)\\right]\\)`;
}

function renderFormula(){
  $('givenFormula').innerHTML = buildGivenFormulaLatex();

  const area=$('formulaArea');
  area.innerHTML='';

  if(state.rule==='mid'){
    const l=document.createElement('div');
    l.className='formulaLine';
    let inner = `<span>\\(h\\big(\\)</span>`;
    for(let i=0;i<state.ys.length;i++){
      inner += `<span class="fSlot" data-slot-id="f_mid_${i}" data-accept="y"></span>`;
      if(i<state.ys.length-1) inner += `<span>\\(+\\)</span>`;
    }
    inner += `<span>\\(\\big)\\)</span>`;
    l.innerHTML=inner;
    area.appendChild(l);
  }

  if(state.rule==='trapezium'){
    const l=document.createElement('div');
    l.className='formulaLine';

    let mids='';
    for(let i=1;i<state.ys.length-1;i++){
      mids += `<span class="fSlot" data-slot-id="f_trap_mid_${i}" data-accept="y"></span>`;
      if(i<state.ys.length-2) mids += `<span>\\(+\\)</span>`;
    }

    l.innerHTML = `
      <span>\\(\\frac{h}{2}\\Big\\{(\\)</span>
      <span class="fSlot" data-slot-id="f_trap_y0" data-accept="y"></span>
      <span>\\(+\\)</span>
      <span class="fSlot" data-slot-id="f_trap_yn" data-accept="y"></span>
      <span>\\()\\,+\\,2(\\)</span>
      ${mids}
      <span>\\()\\Big\\}\\)</span>
    `;
    area.appendChild(l);
  }

  if(state.rule==='simpson'){
    const l=document.createElement('div');
    l.className='formulaLine';

    const odds=[], evens=[];
    for(let i=1;i<state.ys.length-1;i++){
      (i%2===1?odds:evens).push(i);
    }
    let oddBits='', evenBits='';
    for(let k=0;k<odds.length;k++){
      const i=odds[k];
      oddBits += `<span class="fSlot" data-slot-id="f_simp_odd_${i}" data-accept="y"></span>`;
      if(k<odds.length-1) oddBits += `<span>\\(+\\)</span>`;
    }
    for(let k=0;k<evens.length;k++){
      const i=evens[k];
      evenBits += `<span class="fSlot" data-slot-id="f_simp_even_${i}" data-accept="y"></span>`;
      if(k<evens.length-1) evenBits += `<span>\\(+\\)</span>`;
    }

    l.innerHTML = `
      <span>\\(\\frac{h}{3}\\Big[\\,(\\)</span>
      <span class="fSlot" data-slot-id="f_simp_y0" data-accept="y"></span>
      <span>\\(+\\)</span>
      <span class="fSlot" data-slot-id="f_simp_yn" data-accept="y"></span>
      <span>\\()\\,+\\,4(\\)</span>
      ${oddBits}
      <span>\\()\\,+\\,2(\\)</span>
      ${evenBits}
      <span>\\()\\Big]\\)</span>
    `;
    area.appendChild(l);
  }

  document.querySelectorAll('.fSlot').forEach(slot=>{
    slot.addEventListener('click', ()=> clearSlot(slot));
  });

  redrawPlaced();
}

function rerenderMath(){
  if(!window.MathJax || !window.MathJax.typesetPromise){
    $('mjWarn').style.display='block';
    return;
  }
  window.MathJax.typesetPromise().catch(()=> $('mjWarn').style.display='block');
}

/* =========================
   Used token disabling (prevents "duplicates")
   - Table phase: any token placed into table disables that bank token
   - Formula phase: any token placed into formula disables that bank token
   ========================= */
function refreshBankUsedStates(){
  // clear used
  for(const el of state.bankEls.values()) el.classList.remove('used');

  // mark used in table
  for(const tokenId of state.tableSlots.values()){
    const el = state.bankEls.get(tokenId);
    if(el) el.classList.add('used');
  }
  // mark used in formula
  for(const tokenId of state.formulaSlots.values()){
    const el = state.bankEls.get(tokenId);
    if(el) el.classList.add('used');
  }
}

/* =========================
   Slots
   ========================= */
function paintSlot(slotEl, tokenId){
  const tok=state.tokens.get(tokenId);
  slotEl.classList.add('filled');
  slotEl.innerHTML='';
  const t=document.createElement('div');
  t.className=`token ${tok.type} small`;
  t.textContent=tok.label;
  t.dataset.tokenId=tokenId;
  t.dataset.type=tok.type;
  makeDraggable(t);
  slotEl.appendChild(t);
}

function handleDropOn(slotEl, tokenId, tokenType){
  const accept=slotEl.dataset.accept;
  if(accept && accept!==tokenType) return;

  const slotId=slotEl.dataset.slotId;
  if(!slotId) return;

  // gating
  if(slotId.startsWith('t_') && !state.hOk) return;
  if(slotId.startsWith('f_') && !state.tableComplete) return;

  // choose map
  const map = slotId.startsWith('t_') ? state.tableSlots : state.formulaSlots;

  // if token already used in SAME map, move it (clear old slot)
  for(const [sId, tId] of map.entries()){
    if(tId===tokenId && sId!==slotId){
      const old=document.querySelector(`[data-slot-id="${sId}"]`);
      if(old) clearSlot(old, true);
      break;
    }
  }

  clearSlot(slotEl, true);
  map.set(slotId, tokenId);
  paintSlot(slotEl, tokenId);

  refreshBankUsedStates();
}

function clearSlot(slotEl, silent=false){
  const slotId=slotEl.dataset.slotId;
  if(!slotId) return;
  const map = slotId.startsWith('t_') ? state.tableSlots : state.formulaSlots;
  map.delete(slotId);
  slotEl.classList.remove('filled','ok','bad');
  slotEl.innerHTML='';
  refreshBankUsedStates();
}

function redrawPlaced(){
  for(const [slotId, tokenId] of state.tableSlots.entries()){
    const el=document.querySelector(`[data-slot-id="${slotId}"]`);
    if(el) paintSlot(el, tokenId);
  }
  for(const [slotId, tokenId] of state.formulaSlots.entries()){
    const el=document.querySelector(`[data-slot-id="${slotId}"]`);
    if(el) paintSlot(el, tokenId);
  }
  refreshBankUsedStates();
}

/* =========================
   Locks
   ========================= */
function updateLocks(){
  $('dot0').className='dot '+(state.hOk?'good':'lock');
  $('dot1').className='dot '+(state.tableComplete?'good':'lock');
  $('dot2').className='dot '+(state.formulaComplete?'good':'lock');
  $('dot3').className='dot lock';

  $('step1Wrap').classList.toggle('lockOverlay', !state.hOk);
  $('step2Wrap').classList.toggle('lockOverlay', !state.tableComplete);
  $('step3Wrap').classList.toggle('lockOverlay', !state.formulaComplete);

  // once table is complete, bank should not distract — but still visible; we just fade it
  $('bankWrap').classList.toggle('lockOverlay', state.tableComplete);
}

/* =========================
   Checks
   ========================= */
function checkStep0(){
  const raw=$('hBox').value.trim().replace(/,/g,'');
  const val=Number(raw);
  const msg=$('msg0');

  if(!Number.isFinite(val)){
    msg.className='msg warn'; msg.textContent='Enter a valid number for h (3 d.p.).';
    msg.classList.remove('hidden');
    state.hOk=false;
    resetDownstream();
    updateLocks();
    return;
  }

  const target=to3(state.h);
  const entered=to3(val);

  if(entered===target){
    msg.className='msg good';
    msg.innerHTML=`<strong>Correct ✅</strong>  \\(h=${fmt3(target)}\\).`;
    msg.classList.remove('hidden');
    state.hOk=true;
  } else {
    msg.className='msg bad';
    msg.innerHTML=`<strong>Not quite ❌</strong>`;
    msg.classList.remove('hidden');
    state.hOk=false;
    resetDownstream();
  }
  updateLocks();
  rerenderMath();
}

function checkStep1(){
  const msg=$('msg1');
  let allFilled=true, allCorrect=true;

  for(const [slotId, expected] of state.correctTable.entries()){
    const el=document.querySelector(`[data-slot-id="${slotId}"]`);
    const placed=state.tableSlots.get(slotId);

    if(!placed){
      allFilled=false;
      if(el) el.classList.remove('ok','bad');
      continue;
    }
    if(el){
      el.classList.remove('ok','bad');
      el.classList.add(placed===expected?'ok':'bad');
    }
    if(placed!==expected) allCorrect=false;
  }

  if(!allFilled){
    msg.className='msg warn'; msg.textContent='Fill every table slot first.';
    msg.classList.remove('hidden');
    state.tableComplete=false;
    resetStep2(true); resetStep3(true);
    updateLocks();
    return;
  }
  if(!allCorrect){
    msg.className='msg bad'; msg.textContent='Some entries are incorrect — fix the red-outlined slots.';
    msg.classList.remove('hidden');
    state.tableComplete=false;
    resetStep2(true); resetStep3(true);
    updateLocks();
    return;
  }

  msg.className='msg good'; msg.textContent='Perfect — Step 2 unlocked.';
  msg.classList.remove('hidden');
  state.tableComplete=true;
  updateLocks();
}

function checkStep2(){
  const msg=$('msg2');
  let allFilled=true, allCorrect=true;

  for(const [slotId, expected] of state.correctFormula.entries()){
    const el=document.querySelector(`[data-slot-id="${slotId}"]`);
    const placed=state.formulaSlots.get(slotId);

    if(!placed){
      allFilled=false;
      if(el) el.classList.remove('ok','bad');
      continue;
    }
    if(el){
      el.classList.remove('ok','bad');
      el.classList.add(placed===expected?'ok':'bad');
    }
    if(placed!==expected) allCorrect=false;
  }

  if(!allFilled){
    msg.className='msg warn'; msg.textContent='Fill every formula box first.';
    msg.classList.remove('hidden');
    state.formulaComplete=false;
    resetStep3(true);
    updateLocks();
    return;
  }
  if(!allCorrect){
    msg.className='msg bad'; msg.textContent='Some placements are wrong — fix the red-outlined boxes.';
    msg.classList.remove('hidden');
    state.formulaComplete=false;
    resetStep3(true);
    updateLocks();
    return;
  }

  msg.className='msg good'; msg.textContent='Great — Step 3 unlocked.';
  msg.classList.remove('hidden');
  state.formulaComplete=true;
  updateLocks();
}

function checkStep3(){
  const raw=$('answerBox').value.trim().replace(/,/g,'');
  const val=Number(raw);
  const box=$('resultBox');

  if(!Number.isFinite(val)){
    box.className='msg warn'; box.textContent='Please enter a valid number.';
    box.classList.remove('hidden');
    return;
  }

  const expected=state.approxValueRounded;
  const tol=Math.max(0.01, 0.005*Math.abs(expected));
  const err=Math.abs(val-expected);

  if(err<=tol){
    box.className='msg good';
    box.innerHTML=
      `<strong>Correct ✅</strong><br/>
       Expected (using rounded table values): <strong>${expected.toFixed(4)}</strong>`;
  } else {
    box.className='msg bad';
    box.innerHTML=
      `<strong>Not quite ❌</strong><br/>
       Expected (using rounded table values): <strong>${expected.toFixed(4)}</strong><br/>
       Marked correct within <strong>${tol.toFixed(4)}</strong>.`;
  }
  box.classList.remove('hidden');
}

function resetDownstream(){
  resetStep1(true); resetStep2(true); resetStep3(true);
}

function resetStep1(silent){
  state.tableSlots.clear();
  state.tableComplete=false;
  document.querySelectorAll('.slot').forEach(s=>{
    s.classList.remove('filled','ok','bad');
    s.innerHTML='';
  });
  refreshBankUsedStates();
  if(!silent) $('msg1').classList.add('hidden');
}
function resetStep2(silent){
  state.formulaSlots.clear();
  state.formulaComplete=false;
  document.querySelectorAll('.fSlot').forEach(s=>{
    s.classList.remove('filled','ok','bad');
    s.innerHTML='';
  });
  refreshBankUsedStates();
  if(!silent) $('msg2').classList.add('hidden');
}
function resetStep3(silent){
  $('answerBox').value='';
  $('resultBox').classList.add('hidden');
  if(!silent) $('resultBox').textContent='';
}

function clearMessages(){
  $('msg0').classList.add('hidden');
  $('msg1').classList.add('hidden');
  $('msg2').classList.add('hidden');
  $('resultBox').classList.add('hidden');
  $('hBox').value='';
  $('answerBox').value='';
}

/* =========================
   Buttons
   ========================= */
$('btnNew').addEventListener('click', ()=>buildQuestion($('ruleSelect').value));
$('ruleSelect').addEventListener('change', ()=>buildQuestion($('ruleSelect').value));

$('btnCheck0').addEventListener('click', checkStep0);
$('btnCheck1').addEventListener('click', checkStep1);
$('btnCheck2').addEventListener('click', checkStep2);
$('btnCheck3').addEventListener('click', checkStep3);

$('btnReset1').addEventListener('click', ()=>{
  resetStep1(false); resetStep2(true); resetStep3(true);
  updateLocks();
});
$('btnReset2').addEventListener('click', ()=>{
  resetStep2(false); resetStep3(true);
  updateLocks();
});

/* Fullscreen */
$('btnFullscreen').addEventListener('click', async ()=>{
  try{
    if(!document.fullscreenElement){
      await document.documentElement.requestFullscreen();
      $('btnFullscreen').textContent='Exit fullscreen';
    } else {
      await document.exitFullscreen();
      $('btnFullscreen').textContent='Fullscreen';
    }
  } catch(e){
    alert('Fullscreen not available on this device/browser.');
  }
});
document.addEventListener('fullscreenchange', ()=>{
  $('btnFullscreen').textContent = document.fullscreenElement ? 'Exit fullscreen' : 'Fullscreen';
});

/* Init */
buildQuestion($('ruleSelect').value);
window.addEventListener('load', ()=>rerenderMath());
</script>

</body>
</html>
