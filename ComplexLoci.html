<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Complex Locus Selector</title>
  <style>
    :root{
      --bg:#f5f7fb; --card:#fff; --ink:#111; --muted:#667085;
      --line:#e6e8ee; --accent:#f59e0b; --good:#16a34a; --bad:#dc2626;
    }
    body{margin:0; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--ink);}
    .wrap{max-width:980px; margin:0 auto; padding:18px;}
    .top{display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    h1{font-size:18px; margin:0;}
    .pillrow{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
    .pill{
      background:var(--card); border:1px solid var(--line); border-radius:999px;
      padding:6px 10px; font-size:13px; color:var(--muted);
    }
    .pill strong{color:var(--ink); font-weight:700;}
    select{
      border:1px solid var(--line);
      border-radius:999px;
      padding:6px 10px;
      background:#fff;
      color:var(--ink);
      font-weight:700;
      font-size:13px;
      outline:none;
      cursor:pointer;
    }
    .card{
      margin-top:12px;
      background:var(--card); border:1px solid var(--line); border-radius:16px;
      box-shadow:0 10px 18px rgba(0,0,0,.05);
      padding:16px;
    }
    .locus{
      font-size:18px;
      line-height:1.35;
      padding:10px 12px;
      border:1px dashed var(--line);
      border-radius:12px;
      background:#fcfcff;
      overflow:auto;
    }
    .sub{margin:10px 0 0; color:var(--muted); font-size:13px;}
    .grid{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:10px;
      margin-top:12px;
    }
    @media (max-width:700px){ .grid{grid-template-columns:1fr;} .locus{font-size:17px;} }
    .opt{
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
      display:flex;
      gap:12px;
      align-items:center;
      cursor:pointer;
      user-select:none;
      transition:.12s transform, .12s box-shadow, .12s border-color, .12s background;
      background:#fff;
    }
    .opt:hover{transform:translateY(-1px); box-shadow:0 8px 14px rgba(0,0,0,.05);}
    .opt .tag{
      width:34px; height:34px; border-radius:10px;
      display:grid; place-items:center;
      border:1px solid var(--line); color:var(--muted);
      font-weight:800;
      flex:0 0 auto;
    }
    .opt .txt{font-size:16px;}
    .opt.selected{
      border-color: rgba(245,158,11,.55);
      background: rgba(245,158,11,.08);
    }
    .opt.selected .tag{
      border-color: rgba(245,158,11,.65);
      color: var(--ink);
      background: rgba(245,158,11,.12);
    }
    .opt.reveal-good{border-color:rgba(22,163,74,.45); background:rgba(22,163,74,.06);}
    .opt.reveal-bad{border-color:rgba(220,38,38,.40); background:rgba(220,38,38,.05);}
    .controls{
      margin-top:14px;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    button{
      border:0;
      background:var(--accent);
      color:#111;
      padding:10px 14px;
      border-radius:12px;
      font-weight:900;
      cursor:pointer;
      box-shadow:0 10px 18px rgba(245,158,11,.20);
      transition:.12s transform, .12s opacity;
    }
    button:hover{transform:translateY(-1px);}
    button:disabled{opacity:.45; cursor:not-allowed; transform:none; box-shadow:none;}
    .ghost{
      background:#fff;
      border:1px solid var(--line);
      color:var(--ink);
      box-shadow:none;
      font-weight:800;
    }
    .msg{
      font-size:14px; color:var(--muted);
      padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background:#fff;
      flex:1 1 auto;
      min-width:240px;
    }
    .msg.good{border-color:rgba(22,163,74,.35); color:var(--good); background:rgba(22,163,74,.06);}
    .msg.bad{border-color:rgba(220,38,38,.35); color:var(--bad); background:rgba(220,38,38,.06);}
    .tiny{font-size:12px; color:var(--muted); margin-top:6px;}
  </style>

  <script>
    window.MathJax = { tex: {inlineMath: [['\\(','\\)'], ['$', '$']]} };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
  <div class="wrap">
    <div class="top">
      <h1>Complex Locus: pick all \(z\) that satisfy</h1>
      <div class="pillrow">
        <div class="pill">Level: <strong id="levelLbl">1</strong></div>
        <div class="pill">Mode: <strong id="modeLbl">Fixed order</strong></div>
        <div class="pill">Options:
          <select id="numOptSel" aria-label="Number of answer options">
            <!-- filled by JS -->
          </select>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="locus" id="locusBox">Loading…</div>
      <div class="sub">Click one or more options, then click <b>Check</b>.</div>

      <div class="grid" id="options"></div>

      <div class="controls">
        <button id="checkBtn">Check</button>
        <button id="newBtn" class="ghost" title="New question (same level)">New question</button>
        <button id="moveOnBtn" class="ghost" style="display:none;">Move on</button>
        <div class="msg" id="msgBox">Select your answer(s).</div>
      </div>

      <div class="tiny" id="cooldownLbl"></div>
    </div>
  </div>

<script>
(() => {
  // ================== helpers ==================
  const rnd = (a,b) => a + Math.random()*(b-a);
  const rndi = (a,b) => Math.floor(rnd(a,b+1));
  const choice = arr => arr[Math.floor(Math.random()*arr.length)];
  const EPS = 1e-6;

  function nearly(a,b,eps=1e-6){ return Math.abs(a-b) <= eps; }
  function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ [a,b]=[b,a%b]; } return a||1; }
  function rat(n, d){
    if (n===0) return "0";
    const sign = (n*d<0) ? -1 : 1;
    n=Math.abs(n); d=Math.abs(d);
    const g=gcd(n,d);
    n/=g; d/=g;
    const s = sign<0 ? "-" : "";
    return d===1 ? s+String(n) : s+String(n)+"/"+String(d);
  }

  function fmtNumber(x){
    const nearestInt = Math.round(x);
    if (nearly(x, nearestInt, 1e-9)) return String(nearestInt);
    const q = Math.round(x*4);
    if (nearly(x, q/4, 1e-9)) return rat(q,4);
    const h = Math.round(x*2);
    if (nearly(x, h/2, 1e-9)) return rat(h,2);
    return x.toFixed(2).replace(/\.00$/,'');
  }

  function C(re,im){ return {re,im}; }
  function sub(z,w){ return {re:z.re-w.re, im:z.im-w.im}; }
  function add(z,w){ return {re:z.re+w.re, im:z.im+w.im}; }
  function mulScalar(z,t){ return {re:z.re*t, im:z.im*t}; }
  function norm(z){ return Math.hypot(z.re,z.im); }
  function dot(a,b){ return a.re*b.re + a.im*b.im; }
  function cross(a,b){ return a.re*b.im - a.im*b.re; }
  function arg(z){ return Math.atan2(z.im, z.re); }
  function wrapPi(x){
    while (x<=-Math.PI) x+=2*Math.PI;
    while (x> Math.PI) x-=2*Math.PI;
    return x;
  }
  function sameArg(v1,v2){
    // same direction: collinear + dot positive
    return Math.abs(cross(v1,v2)) <= 1e-6 && dot(v1,v2) > 1e-6;
  }

  function randomComplex(range=6, step=0.5){
    const vals = [];
    for (let x=-range; x<=range+1e-9; x+=step) vals.push(+x.toFixed(3));
    const re = choice(vals);
    const im = choice(vals);
    return {re,im};
  }

  function randomNonEqualComplex(existing, range=6, step=0.5){
    for (let tries=0; tries<800; tries++){
      const z = randomComplex(range, step);
      let ok = true;
      for (const e of existing){
        if (Math.hypot(z.re-e.re, z.im-e.im) < 1e-9){ ok=false; break; }
      }
      if (ok) return z;
    }
    return randomComplex(range, step);
  }

  // ================== "no brackets" complex expression ==================
  // Returns a TeX string for: z - a  (expanded, no parentheses/brackets), e.g.
  // a=3+2i -> z-3-2i
  // a=-1+4i -> z+1-4i
  // a=0-3i -> z+3i
  function texZMinus(a){
    const parts = ["z"];
    const re = a.re;
    const im = a.im;

    if (!nearly(re,0,1e-9)){
      const s = re>0 ? "-" : "+";
      parts.push(s + fmtNumber(Math.abs(re)));
    }
    if (!nearly(im,0,1e-9)){
      // subtract (im i): z - (im i) => if im>0 then "- ...i" else "+ ...i"
      const s = im>0 ? "-" : "+";
      const mag = fmtNumber(Math.abs(im));
      // avoid "1i" if you want: keep as i
      const imTxt = (mag === "1") ? "i" : mag + "i";
      parts.push(s + imTxt);
    }
    return parts.join("");
  }

  // TeX string for z = a (no brackets)
  function texZEquals(z){
    const re0 = nearly(z.re,0,1e-9);
    const im0 = nearly(z.im,0,1e-9);
    const a = fmtNumber(z.re);
    const b = fmtNumber(Math.abs(z.im));

    if (im0) return `z=${a}`;
    if (re0){
      const sign = z.im<0 ? "-" : "";
      const imTxt = (b === "1") ? "i" : b+"i";
      return `z=${sign}${imTxt}`;
    }
    const sign = z.im<0 ? "-" : "+";
    const imTxt = (b === "1") ? "i" : b+"i";
    return `z=${a}${sign}${imTxt}`;
  }

  // ================== exact radian angles in (-pi, pi] ==================
  // choose from "nice" exact values
  const ANGLES = [
    {n:-11, d:12},{n:-5,d:6},{n:-3,d:4},{n:-2,d:3},{n:-7,d:12},{n:-1,d:2},{n:-5,d:12},{n:-1,d:3},{n:-1,d:4},{n:-1,d:6},{n:-1,d:12},
    {n:0,d:1},
    {n:1,d:12},{n:1,d:6},{n:1,d:4},{n:1,d:3},{n:5,d:12},{n:1,d:2},{n:7,d:12},{n:2,d:3},{n:3,d:4},{n:5,d:6},{n:11,d:12},
    {n:1,d:1} // pi
  ];

  function angleToTex(fr){
    // fr represents (n/d) * pi, reduced, in (-pi, pi]
    const n = fr.n, d = fr.d;
    if (n === 0) return "0";
    if (d === 1){
      if (n === 1) return "\\pi";
      if (n === -1) return "-\\pi";
      return (n<0? "-" : "") + String(Math.abs(n)) + "\\pi";
    }
    const absN = Math.abs(n);
    const num = absN === 1 ? "\\pi" : absN + "\\pi";
    const tex = "\\frac{" + num + "}{" + d + "}";
    return n < 0 ? "-" + tex : tex;
  }

  function angleToRadians(fr){ return (fr.n/fr.d) * Math.PI; }

  // ================== locus types & generators ==================
  const TYPES = [
    { id: 0, name: "|z-a|=k" },
    { id: 1, name: "arg z-a = θ" },
    { id: 2, name: "|z-a|=|z-b|" },
    { id: 3, name: "arg z-a = arg z-b" }
  ];

  let level = 1;
  let current = null;
  let selected = new Set();
  let cooldownTimer = null;
  let cooldownUntil = 0;
  let attempts = 0; // checks used on current question

  const el = {
    levelLbl: document.getElementById("levelLbl"),
    modeLbl: document.getElementById("modeLbl"),
    locusBox: document.getElementById("locusBox"),
    options: document.getElementById("options"),
    checkBtn: document.getElementById("checkBtn"),
    newBtn: document.getElementById("newBtn"),
    moveOnBtn: document.getElementById("moveOnBtn"),
    msgBox: document.getElementById("msgBox"),
    cooldownLbl: document.getElementById("cooldownLbl"),
    numOptSel: document.getElementById("numOptSel"),
  };

  function setMsg(text, kind=""){
    el.msgBox.classList.remove("good","bad");
    if (kind) el.msgBox.classList.add(kind);
    el.msgBox.textContent = text;
  }

  function clearCooldown(){
    if (cooldownTimer) clearInterval(cooldownTimer);
    cooldownTimer = null;
    cooldownUntil = 0;
    el.cooldownLbl.textContent = "";
    el.checkBtn.disabled = false;
  }

  function startCooldown(seconds=60){
    cooldownUntil = Date.now() + seconds*1000;
    el.checkBtn.disabled = true;

    const tick = () => {
      const left = Math.max(0, Math.ceil((cooldownUntil - Date.now())/1000));
      if (left <= 0){
        clearCooldown();
        // keep current message as-is
        return;
      }
      el.cooldownLbl.textContent = `Check locked for ${left}s after an incorrect answer.`;
    };
    tick();
    cooldownTimer = setInterval(tick, 250);
  }

  function pickTypeForLevel(level){
    if (level === 1) return 0;
    if (level === 2) return 1;
    if (level === 3) return 2;
    if (level === 4) return 3;
    return choice([0,1,2,3]);
  }

  function makeQuestion(typeId, numOptions){
    // ensure 1–3 correct among numOptions (up to 20)
    for (let attempt=0; attempt<500; attempt++){
      const a = randomComplex(6, 0.5);
      let b = null;

      if (typeId === 2 || typeId === 3){
        b = randomNonEqualComplex([a], 6, 0.5);
        if (norm(sub(a,b)) < 1.5) continue;
      }

      let statementTex = "";
      let checker = (z) => false;

      if (typeId === 0){
        const k = choice([1,1.5,2,2.5,3,3.5,4]);
        statementTex = `\\(\\left|${texZMinus(a)}\\right|=${fmtNumber(k)}\\)`;
        checker = (z) => nearly(norm(sub(z,a)), k, 2e-3);

        const angles = [0, Math.PI/2, Math.PI, 3*Math.PI/2, Math.PI/4, 3*Math.PI/4, 5*Math.PI/4, 7*Math.PI/4];
        const goodCandidates = angles.map(t => add(a, {re:k*Math.cos(t), im:k*Math.sin(t)}));
        const pool = [];
        const snap = (z) => ({re: Math.round(z.re*2)/2, im: Math.round(z.im*2)/2});
        for (const g of goodCandidates) pool.push(snap(g));
        while (pool.length < 40) pool.push(randomComplex(6,0.5));

        const options = [];
        const used = new Set();
        const takeUnique = (z) => {
          const key = z.re.toFixed(3)+","+z.im.toFixed(3);
          if (used.has(key)) return false;
          used.add(key);
          options.push(z);
          return true;
        };
        let tries=0;
        while (options.length < numOptions && tries++<3000){
          takeUnique(choice(pool));
        }

        const correct = options.map(checker);
        const count = correct.filter(Boolean).length;
        if (count>=1 && count<=3) return {typeId,a,b,statementTex,options,correct};
      }

      if (typeId === 1){
        const fr = choice(ANGLES);
        const theta = angleToRadians(fr);
        const thetaTex = angleToTex(fr);

        statementTex = `\\(\\arg\\,${texZMinus(a)}=${thetaTex}\\)`;
        checker = (z) => {
          const v = sub(z,a);
          if (norm(v) < 1e-6) return false;
          const d = wrapPi(arg(v) - theta);
          return Math.abs(d) < 1e-3;
        };

        const dir = {re: Math.cos(theta), im: Math.sin(theta)};
        const rs = choice([[1,2,3],[1.5,2.5,3.5],[2,4,5],[1,3,5]]);
        const good = rs.map(r => add(a, mulScalar(dir, r)));
        const bad = [
          add(a, mulScalar({re:Math.cos(theta+Math.PI/6), im:Math.sin(theta+Math.PI/6)}, choice([2,3,4]))),
          add(a, mulScalar({re:Math.cos(theta-Math.PI/5), im:Math.sin(theta-Math.PI/5)}, choice([2,3,4]))),
          randomComplex(6,0.5),
          randomComplex(6,0.5),
        ];

        const pool = [];
        const snap = (z) => ({re: Math.round(z.re*2)/2, im: Math.round(z.im*2)/2});
        [...good, ...bad].forEach(z => pool.push(snap(z)));
        while (pool.length < 45) pool.push(randomComplex(6,0.5));

        const options = [];
        const used = new Set();
        const takeUnique = (z) => {
          const key = z.re.toFixed(3)+","+z.im.toFixed(3);
          if (used.has(key)) return false;
          used.add(key);
          options.push(z);
          return true;
        };
        let tries=0;
        while (options.length < numOptions && tries++<3500){
          takeUnique(choice(pool));
        }

        const correct = options.map(checker);
        const count = correct.filter(Boolean).length;
        if (count>=1 && count<=3) return {typeId,a,b,statementTex,options,correct};
      }

      if (typeId === 2){
        statementTex = `\\(\\left|${texZMinus(a)}\\right|=\\left|${texZMinus(b)}\\right|\\)`;
        checker = (z) => nearly(norm(sub(z,a)), norm(sub(z,b)), 2e-3);

        const m = mulScalar(add(a,b), 0.5);
        const d = sub(b,a);
        const perp = {re:-d.im, im:d.re};
        const perpNorm = norm(perp);
        if (perpNorm < 1e-6) continue;

        const dir = mulScalar(perp, 1/perpNorm);
        const ts = choice([[ -4,-2,2,4],[-3,-1,1,3],[-5,-2.5,2.5,5]]);
        const good = ts.map(t => add(m, mulScalar(dir, t)));

        const pool = [];
        const snap = (z) => ({re: Math.round(z.re*2)/2, im: Math.round(z.im*2)/2});
        good.forEach(z => pool.push(snap(z)));
        while (pool.length < 55) pool.push(randomComplex(6,0.5));

        const options = [];
        const used = new Set();
        const takeUnique = (z) => {
          const key = z.re.toFixed(3)+","+z.im.toFixed(3);
          if (used.has(key)) return false;
          used.add(key);
          options.push(z);
          return true;
        };
        let tries=0;
        while (options.length < numOptions && tries++<5000){
          takeUnique(choice(pool));
        }

        const correct = options.map(checker);
        const count = correct.filter(Boolean).length;
        if (count>=1 && count<=3) return {typeId,a,b,statementTex,options,correct};
      }

      if (typeId === 3){
        statementTex = `\\(\\arg\\,${texZMinus(a)}=\\arg\\,${texZMinus(b)}\\)`;
        checker = (z) => {
          const v1 = sub(z,a);
          const v2 = sub(z,b);
          if (norm(v1) < 1e-6 || norm(v2) < 1e-6) return false;
          return sameArg(v1,v2);
        };

        const d = sub(b,a);
        const dn = norm(d);
        if (dn < 1e-6) continue;
        const dir = mulScalar(d, 1/dn);

        const ts = choice([[1,2,3],[1.5,2.5,3.5],[2,4,5]]);
        const good = [];
        ts.forEach(t => good.push(add(a, mulScalar(dir, -t))));
        ts.forEach(t => good.push(add(b, mulScalar(dir, +t))));

        const between = [];
        [0.25, 0.5, 0.75].forEach(u => between.push(add(a, mulScalar(d, u))));

        const pool = [];
        const snap = (z) => ({re: Math.round(z.re*2)/2, im: Math.round(z.im*2)/2});
        [...good, ...between].forEach(z => pool.push(snap(z)));
        while (pool.length < 60) pool.push(randomComplex(6,0.5));

        const options = [];
        const used = new Set();
        const takeUnique = (z) => {
          const key = z.re.toFixed(3)+","+z.im.toFixed(3);
          if (used.has(key)) return false;
          used.add(key);
          options.push(z);
          return true;
        };
        let tries=0;
        while (options.length < numOptions && tries++<6000){
          takeUnique(choice(pool));
        }

        const correct = options.map(checker);
        const count = correct.filter(Boolean).length;
        if (count>=1 && count<=3) return {typeId,a,b,statementTex,options,correct};
      }
    }

    // fallback
    const a = randomComplex(6,0.5);
    const statementTex = `\\(\\left|${texZMinus(a)}\\right|=2\\)`;
    const options = Array.from({length:numOptions}, () => randomComplex(6,0.5));
    const correct = options.map(_=>false); correct[0]=true;
    return {typeId:0,a,b:null,statementTex,options,correct};
  }

  // ================== UI ==================
  function typeset(){
    if (window.MathJax && window.MathJax.typesetPromise){
      window.MathJax.typesetPromise().catch(()=>{});
    }
  }

  function clearRevealStyles(){
    [...el.options.children].forEach(node => {
      node.classList.remove("reveal-good","reveal-bad");
    });
  }

  function revealSolution(){
    clearRevealStyles();
    const wanted = current.correct
      .map((ok,i)=> ok?i:null)
      .filter(v=>v!==null);

    // mark correct/incorrect relative to truth (not relative to user's selection)
    [...el.options.children].forEach((node, idx) => {
      if (wanted.includes(idx)) node.classList.add("reveal-good");
      else node.classList.add("reveal-bad");
    });

    const wantedHuman = wanted.map(i => i+1).join(", ");
    setMsg(`Correct option(s): ${wantedHuman}. Do you need to ask for help before moving on?`, "bad");
    el.moveOnBtn.style.display = "";
  }

  function renderQuestion(q){
    current = q;
    selected.clear();
    attempts = 0;
    el.moveOnBtn.style.display = "none";
    clearCooldown();

    const fixed = level <= 4;
    el.levelLbl.textContent = String(level);
    el.modeLbl.textContent = fixed ? "Fixed order" : "Random";

    el.locusBox.innerHTML = q.statementTex;
    el.options.innerHTML = "";

    // responsive columns: 1 col on small, 2 on mid, 3+ on big when many options
    const n = q.options.length;
    if (n >= 13) el.options.style.gridTemplateColumns = "repeat(4, minmax(0,1fr))";
    else if (n >= 9) el.options.style.gridTemplateColumns = "repeat(3, minmax(0,1fr))";
    else el.options.style.gridTemplateColumns = (window.innerWidth <= 700) ? "1fr" : "repeat(2, minmax(0,1fr))";

    q.options.forEach((z, idx) => {
      const card = document.createElement("div");
      card.className = "opt";
      card.dataset.idx = String(idx);

      const tag = document.createElement("div");
      tag.className = "tag";
      tag.textContent = String(idx+1);

      const txt = document.createElement("div");
      txt.className = "txt";
      // Answer option in MathJax
      txt.innerHTML = `\\(${texZEquals(z)}\\)`;

      card.appendChild(tag);
      card.appendChild(txt);

      card.addEventListener("click", () => {
        // allow selection even after reveal, but it won't matter
        if (card.classList.contains("selected")){
          card.classList.remove("selected");
          selected.delete(idx);
        } else {
          card.classList.add("selected");
          selected.add(idx);
        }
        // if already revealed, keep reveal message
        if (el.moveOnBtn.style.display === "none") setMsg("Select your answer(s).");
      });

      el.options.appendChild(card);
    });

    setMsg("Select your answer(s).");
    typeset();
  }

  function nextQuestion(sameLevel=false){
    const typeId = pickTypeForLevel(level);
    const numOptions = parseInt(el.numOptSel.value, 10);
    const q = makeQuestion(typeId, numOptions);
    renderQuestion(q);
  }

  function checkAnswer(){
    if (!current) return;
    if (Date.now() < cooldownUntil) return;

    attempts += 1;

    const wanted = current.correct
      .map((ok,i)=> ok?i:null)
      .filter(v=>v!==null);

    const chosen = [...selected].sort((a,b)=>a-b);
    const sameLen = chosen.length === wanted.length;
    const same = sameLen && chosen.every((v,i)=>v===wanted[i]);

    if (same){
      clearCooldown();
      el.moveOnBtn.style.display = "none";
      clearRevealStyles();
      setMsg("Correct ✅ Moving to the next level.", "good");
      level += 1;
      setTimeout(() => nextQuestion(true), 350);
    } else {
      if (attempts >= 2){
        // Show solution after second incorrect check
        revealSolution();
        startCooldown(60);
      } else {
        setMsg("Not quite ❌ Check is locked for 60 seconds.", "bad");
        startCooldown(60);
      }
    }
  }

  // ================== events & init ==================
  // fill options dropdown: 4..20
  for (let k=4; k<=20; k++){
    const opt = document.createElement("option");
    opt.value = String(k);
    opt.textContent = String(k);
    if (k === 4) opt.selected = true;
    el.numOptSel.appendChild(opt);
  }

  el.checkBtn.addEventListener("click", checkAnswer);
  el.newBtn.addEventListener("click", () => nextQuestion(true));
  el.moveOnBtn.addEventListener("click", () => {
    // let them move on even if not correct (after reveal)
    clearCooldown();
    level += 1;
    nextQuestion(true);
  });

  el.numOptSel.addEventListener("change", () => {
    // regenerate same level with new count
    nextQuestion(true);
  });

  window.addEventListener("resize", () => {
    // re-render grid columns quickly (no regeneration)
    if (!current) return;
    const n = current.options.length;
    if (n >= 13) el.options.style.gridTemplateColumns = "repeat(4, minmax(0,1fr))";
    else if (n >= 9) el.options.style.gridTemplateColumns = "repeat(3, minmax(0,1fr))";
    else el.options.style.gridTemplateColumns = (window.innerWidth <= 700) ? "1fr" : "repeat(2, minmax(0,1fr))";
  });

  nextQuestion(true);
})();
</script>
</body>
</html>
