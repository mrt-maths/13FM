<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Region Shading</title>

<script>
window.MathJax = {
 tex: {inlineMath: [['\\(','\\)'],['$','$']]}
};
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

<style>
body{
 margin:0;
 font-family:system-ui;
 background:#f5f7fb;
}
.wrap{
 display:grid;
 grid-template-columns:380px 1fr;
 gap:12px;
 padding:12px;
}
.card{
 background:white;
 border-radius:12px;
 border:1px solid #ddd;
 padding:12px;
}
canvas{
 width:100%;
 height:600px;
 border-radius:12px;
 border:1px solid #ddd;
}
button{
 padding:8px 12px;
 border-radius:10px;
 border:1px solid #ddd;
 background:white;
 cursor:pointer;
}
.primary{
 background:#f97316;
 color:white;
 border:none;
}
.msg{
 margin-top:8px;
 padding:8px;
 border-radius:8px;
 border:1px solid #ddd;
}
.warn{background:#fff4e5;}
.good{background:#e8fff1;}
.bad{background:#ffecec;}
</style>
</head>

<body>

<div class="wrap">

<div class="card">
<h3 id="levelLabel">Level 1</h3>

<select id="mode">
<option value="0">Mode 0</option>
<option value="1">Mode 1</option>
<option value="2">Mode 2</option>
<option value="3">Mode 3</option>
<option value="4">Mode 4</option>
<option value="5">Mode 5</option>
<option value="6">Mode 6</option>
</select>

<div id="ineqList"></div>

<button class="primary" id="check">Check</button>
<button id="clear">Clear</button>
<button id="new">New</button>

<div id="msg" class="msg" style="display:none"></div>

<div id="after2" class="msg warn" style="display:none">
Two checks used.<br><br>
<button id="try">Try Again</button>
<button class="primary" id="show">Show Answer</button>
</div>

</div>

<div class="card">
<canvas id="cv" width="1000" height="800"></canvas>
</div>

</div>

<script>

/**********************
CORE CONSTANTS
**********************/

const MIN=-12;
const MAX=12;
const RANGE=24;

const MASK=420;

let mode=0;
let level=1;

let shapes=[];
let inequalities=[];

let regionMap;
let truth=new Set();
let selected=new Set();

let failChecks=0;


/**********************
UTILS
**********************/

const rnd=(a,b)=>a+Math.random()*(b-a);
const pick=a=>a[Math.floor(Math.random()*a.length)];

function nice(x){
 if(Math.abs(x-Math.round(x))<1e-9) return String(Math.round(x));
 return (Math.round(x*10)/10).toString();
}

/**********************
CANVAS
**********************/

const cv=document.getElementById("cv");
const ctx=cv.getContext("2d");

function worldToCanvas(x,y){

 const s=Math.min(cv.width,cv.height);
 const ox=(cv.width-s)/2;
 const oy=(cv.height-s)/2;

 const nx=(x-MIN)/RANGE;
 const ny=(y-MIN)/RANGE;

 return {
  X:ox+nx*s,
  Y:oy+(1-ny)*s
 };
}

/**********************
MASK + REGION BUILD
**********************/

const maskCanvas=document.createElement("canvas");
maskCanvas.width=MASK;
maskCanvas.height=MASK;
const mctx=maskCanvas.getContext("2d");

function boundaryWidth(){
 return mode===6?4:2; // FIX
}

function drawMask(){

 mctx.fillStyle="white";
 mctx.fillRect(0,0,MASK,MASK);

 mctx.strokeStyle="black";
 mctx.lineWidth=boundaryWidth();

 mctx.strokeRect(0,0,MASK,MASK);

 shapes.forEach(s=>s.mask());
}

function buildRegions(){

 const img=mctx.getImageData(0,0,MASK,MASK).data;

 regionMap=new Int32Array(MASK*MASK);

 let id=0;

 const isBoundary=(i)=>img[i]<50;

 const Qx=new Int32Array(MASK*MASK);
 const Qy=new Int32Array(MASK*MASK);

 for(let y=0;y<MASK;y++){
 for(let x=0;x<MASK;x++){

  const idx=y*MASK+x;

  if(regionMap[idx]) continue;
  if(isBoundary(idx*4)) continue;

  id++;

  let head=0,tail=0;
  Qx[tail]=x;
  Qy[tail]=y;
  tail++;

  regionMap[idx]=id;

  while(head<tail){

   const cx=Qx[head];
   const cy=Qy[head];
   head++;

   const n=[[1,0],[-1,0],[0,1],[0,-1]]; // NO diagonals

   for(const [dx,dy] of n){

    const nx=cx+dx;
    const ny=cy+dy;

    if(nx<0||ny<0||nx>=MASK||ny>=MASK) continue;

    const i2=ny*MASK+nx;
    if(regionMap[i2]) continue;
    if(isBoundary(i2*4)) continue;

    regionMap[i2]=id;
    Qx[tail]=nx;
    Qy[tail]=ny;
    tail++;
   }
  }
 }
 }

 return id;
}

/**********************
DRAW
**********************/

function draw(){

 ctx.clearRect(0,0,cv.width,cv.height);

 // fill selected
 for(let y=0;y<MASK;y++){
 for(let x=0;x<MASK;x++){

  const id=regionMap[y*MASK+x];
  if(!selected.has(id)) continue;

  const wx=MIN + x/MASK*RANGE;
  const wy=MIN + (1-y/MASK)*RANGE;

  const p=worldToCanvas(wx,wy);

  ctx.fillStyle="rgba(249,115,22,.3)";
  ctx.fillRect(p.X,p.Y,2,2);
 }
 }

 ctx.strokeStyle="#555";
 ctx.lineWidth=2.5;

 shapes.forEach(s=>s.draw());
}

/**********************
REGION TRUTH
**********************/

function computeTruth(count){

 truth.clear();

 for(let id=1;id<=count;id++){

  let found=false;

  for(let y=0;y<MASK&&!found;y++){
  for(let x=0;x<MASK;x++){

   if(regionMap[y*MASK+x]!==id) continue;

   const wx=MIN+x/MASK*RANGE;
   const wy=MIN+(1-y/MASK)*RANGE;

   if(inequalities.every(f=>f(wx,wy))){
    truth.add(id);
    found=true;
    break;
   }
  }}
 }
}

/**********************
MODE GENERATORS
**********************/

/* MODE 1 — rewritten exactly as requested */

function mode1(){

 shapes=[];
 inequalities=[];

 // ONE vertical only
 const a=Math.round(rnd(-6,6));

 shapes.push({
  draw(){
   const p1=worldToCanvas(a,MIN);
   const p2=worldToCanvas(a,MAX);
   ctx.beginPath();
   ctx.moveTo(p1.X,p1.Y);
   ctx.lineTo(p2.X,p2.Y);
   ctx.stroke();
  },
  mask(){
   const x=(a-MIN)/RANGE*MASK;
   mctx.beginPath();
   mctx.moveTo(x,0);
   mctx.lineTo(x,MASK);
   mctx.stroke();
  }
 });

 inequalities.push((x)=>x>a);

 // distractor y=mx+c lines
 for(let i=0;i<3;i++){

  const m=pick([-2,-1.5,-1,-.5,.5,1,1.5,2]);
  const c=rnd(-6,6);

  shapes.push({
   draw(){
    const p1=worldToCanvas(MIN,m*MIN+c);
    const p2=worldToCanvas(MAX,m*MAX+c);
    ctx.beginPath();
    ctx.moveTo(p1.X,p1.Y);
    ctx.lineTo(p2.X,p2.Y);
    ctx.stroke();
   },
   mask(){
    mctx.beginPath();
    for(let x=0;x<MASK;x++){
     const wx=MIN+x/MASK*RANGE;
     const wy=m*wx+c;
     const y=MASK-(wy-MIN)/RANGE*MASK;
     if(x===0) mctx.moveTo(x,y);
     else mctx.lineTo(x,y);
    }
    mctx.stroke();
   }
  });
 }

 document.getElementById("ineqList").innerHTML=
 `\\(x>${a}\\)`;

}

/**********************
MODE 6 — FIXED diversity
**********************/

function mode6(){

 shapes=[];
 inequalities=[];

 const types=[];

 function addCircle(){
  const cx=rnd(-5,5);
  const cy=rnd(-5,5);
  const r=rnd(2,4);

  shapes.push({
   draw(){
    const p=worldToCanvas(cx,cy);
    const scale=cv.width/RANGE;
    ctx.beginPath();
    ctx.arc(p.X,p.Y,r*scale,0,Math.PI*2);
    ctx.stroke();
   },
   mask(){
    const steps=360;
    mctx.beginPath();
    for(let i=0;i<=steps;i++){
     const t=i/steps*2*Math.PI;
     const x=(cx+r*Math.cos(t)-MIN)/RANGE*MASK;
     const y=MASK-(cy+r*Math.sin(t)-MIN)/RANGE*MASK;
     if(i===0) mctx.moveTo(x,y);
     else mctx.lineTo(x,y);
    }
    mctx.stroke();
   }
  });

  inequalities.push((x,y)=>Math.hypot(x-cx,y-cy)>r);
  types.push("circle");

 }

 function addArg(){

  const a=rnd(-4,4);
  const b=rnd(-4,4);

  const t1=-Math.PI/4;
  const t2=Math.PI/3;

  function ray(theta){

   shapes.push({
    draw(){
     const p=worldToCanvas(a,b);
     const p2=worldToCanvas(a+20*Math.cos(theta),b+20*Math.sin(theta));
     ctx.beginPath();
     ctx.moveTo(p.X,p.Y);
     ctx.lineTo(p2.X,p2.Y);
     ctx.stroke();
    },
    mask(){
     const p1=[(a-MIN)/RANGE*MASK, MASK-(b-MIN)/RANGE*MASK];
     const p2=[p1[0]+100*Math.cos(theta), p1[1]-100*Math.sin(theta)];
     mctx.beginPath();
     mctx.moveTo(...p1);
     mctx.lineTo(...p2);
     mctx.stroke();
    }
   });
  }

  ray(t1);
  ray(t2);

  inequalities.push((x,y)=>{
   const ang=Math.atan2(y-b,x-a);
   return ang>t1 && ang<t2;
  });

  types.push("arg");
 }

 addCircle();

 if(level>1){
  while(new Set(types).size<2){
   if(Math.random()<0.5) addArg();
   else addCircle();
  }
 }

 document.getElementById("ineqList").innerHTML=
 "\\(\\text{Complex loci}\\)";

}

/**********************
CHECK
**********************/

function check(){

 let correct=0,miss=0,wrong=0;

 selected.forEach(id=>{
  if(truth.has(id)) correct++;
  else wrong++;
 });

 truth.forEach(id=>{
  if(!selected.has(id)) miss++;
 });

 const perfect=!wrong&&!miss;

 const msg=document.getElementById("msg");
 msg.style.display="block";
 msg.className="msg "+(perfect?"good":"bad");
 msg.innerText=`${correct} correct, ${wrong} incorrect, ${miss} missed`;

 if(perfect){
  failChecks=0;
  document.getElementById("after2").style.display="none";
  level=Math.min(6,level+1);
  generate();
 }else{
  failChecks++;
  if(failChecks>=2){
   document.getElementById("after2").style.display="block";
  }
 }
}

document.getElementById("check").onclick=check;

document.getElementById("show").onclick=()=>{
 selected=new Set(truth);
 draw();
};

document.getElementById("try").onclick=()=>{
 document.getElementById("after2").style.display="none";
};

/**********************
CLICK
**********************/

cv.onclick=(e)=>{

 const rect=cv.getBoundingClientRect();

 const x=(e.clientX-rect.left)/rect.width*MASK;
 const y=(e.clientY-rect.top)/rect.height*MASK;

 const id=regionMap[Math.floor(y)*MASK+Math.floor(x)];

 if(!id) return;

 if(selected.has(id)) selected.delete(id);
 else selected.add(id);

 draw();
};

/**********************
GENERATE
**********************/

function generate(){

 selected.clear();
 failChecks=0;
 document.getElementById("after2").style.display="none";

 if(mode==1) mode1();
 if(mode==6) mode6();

 drawMask();
 const count=buildRegions();
 computeTruth(count);

 draw();

 if(window.MathJax) MathJax.typeset();
}

document.getElementById("mode").onchange=(e)=>{
 mode=Number(e.target.value);
 level=1;
 generate();
};

document.getElementById("new").onclick=generate;
document.getElementById("clear").onclick=()=>{
 selected.clear();
 draw();
};

generate();

</script>

</body>
</html>
