<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Region Shading (Modes + Zoom + MathJax)</title>

<!-- MathJax (TeX) -->
<script>
  window.MathJax = {
    tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
    options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

<style>
  :root{
    --bg:#f5f7fb; --card:#fff; --ink:#111827; --muted:#6b7280; --line:#e5e7eb;
    --accent:#f97316; --good:#16a34a; --bad:#dc2626; --warn:#d97706;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--ink)}
  header{padding:14px 16px}
  header h1{margin:0;font-size:18px}
  header p{margin:6px 0 0;color:var(--muted);font-size:13px}

  .wrap{display:grid;grid-template-columns:400px 1fr;gap:14px;padding:0 16px 16px}
  @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }

  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;box-shadow:0 8px 18px rgba(0,0,0,.05)}
  .card .hd{padding:12px 14px;border-bottom:1px solid var(--line);display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  .card .bd{padding:12px 14px}

  .btnrow{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  button{
    appearance:none;border:1px solid var(--line);background:#fff;color:var(--ink);
    padding:10px 12px;border-radius:12px;font-weight:650;cursor:pointer;
    transition:.12s; user-select:none;
  }
  button:hover{transform:translateY(-1px);box-shadow:0 10px 16px rgba(0,0,0,.06)}
  button:disabled{opacity:.55;cursor:not-allowed;transform:none;box-shadow:none}
  .primary{background:var(--accent);border-color:transparent;color:#fff}
  .pill{font-size:12px;color:var(--muted);border:1px solid var(--line);padding:6px 10px;border-radius:999px;white-space:nowrap}
  select{
    border:1px solid var(--line); border-radius:12px; padding:10px 12px;
    font-weight:650; background:#fff; color:var(--ink);
  }

  .list{display:flex;flex-direction:column;gap:10px;margin-top:10px}
  .ineq{border:1px solid var(--line);border-radius:12px;padding:10px;background:#fff}
  .ineq .k{font-size:12px;color:var(--muted);margin-bottom:6px}
  .ineq .v{font-size:18px;font-weight:850}
  .ineq .v mjx-container{ font-size: 110% !important; }

  .small{font-size:12px;color:var(--muted)}
  .msg{margin-top:10px;padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:#fafafa}
  .msg.good{border-color:rgba(22,163,74,.35);background:rgba(22,163,74,.08);color:#0f5132}
  .msg.bad{border-color:rgba(220,38,38,.35);background:rgba(220,38,38,.08);color:#7f1d1d}
  .msg.warn{border-color:rgba(217,119,6,.35);background:rgba(217,119,6,.10);color:#7c2d12}

  .canvasWrap{padding:12px}
  canvas{width:100%;height:560px;display:block;border-radius:14px;border:1px solid var(--line);background:#fff;touch-action:none}
  @media (max-width: 980px){ canvas{height:520px} }

  .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
  .sw{display:inline-flex;align-items:center;gap:8px}
  .box{width:14px;height:14px;border-radius:4px;border:1px solid var(--line);background:#fff}
  .box.sel{background:rgba(249,115,22,.20);border-color:rgba(249,115,22,.60)}

  .choiceRow{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
</style>
</head>
<body>
<header>
  <h1>Region Shading — Multiple Modes</h1>
  <p>Click inside a region to fill/unfill it (screen edge is a boundary). Select all regions where <b>all</b> inequalities are true, then press <b>Check</b>. Use mouse wheel / trackpad to zoom (can’t zoom out past default).</p>
</header>

<div class="wrap">
  <section class="card">
    <div class="hd">
      <div class="btnrow">
        <span class="pill" id="levelPill">Level 1 / 6</span>
        <label class="pill" style="display:flex;gap:8px;align-items:center">
          Mode
          <select id="modeSel" aria-label="Mode">
            <option value="0">Mode 0: x=a and y=b only</option>
            <option value="1">Mode 1: exactly one inequality x&gt;a / x&lt;a</option>
            <option value="2">Mode 2: lines + parabolas</option>
            <option value="3">Mode 3: lines + parabolas + cubics</option>
            <option value="4">Mode 4: lines + sine waves</option>
            <option value="5">Mode 5: lines + exponentials</option>
            <option value="6">Mode 6: complex loci</option>
          </select>
        </label>
      </div>
      <div class="btnrow">
        <button id="clearBtn">Clear shading</button>
        <button id="newBtn">New image</button>
      </div>
    </div>

    <div class="bd">
      <div class="small" id="modeHelp"></div>

      <div class="list" id="ineqList"></div>

      <div class="msg warn" id="hintBox" style="display:none"></div>
      <div class="msg" id="statusBox" style="display:none"></div>

      <div class="msg warn" id="after2Box" style="display:none">
        You’ve had two checks. What would you like to do?
        <div class="choiceRow">
          <button id="tryAgainBtn">Try again</button>
          <button id="showAnsBtn" class="primary">Show correct answer</button>
        </div>
      </div>

      <div style="height:10px"></div>
      <div class="btnrow">
        <button class="primary" id="checkBtn">Check</button>
        <span class="pill" id="timerPill" style="display:none">Check available in 60s</span>
      </div>

      <div class="legend">
        <span class="sw"><span class="box sel"></span><span class="small">selected region</span></span>
        <span class="sw"><span class="box"></span><span class="small">unselected region</span></span>
      </div>
      <div class="small" style="margin-top:10px">
        View is 1:1. Default axes are from −12 to 12.
      </div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div class="pill">Click / tap inside a region</div>
      <div class="pill" id="zoomPill">Zoom: 100%</div>
    </div>
    <div class="canvasWrap">
      <canvas id="cv" width="1200" height="800"></canvas>
    </div>
  </section>
</div>

<script>
(() => {
  // ======= BASE WORLD (USED FOR REGION FINDING / MASK) =======
  const BASE_MIN = -12, BASE_MAX = 12;
  const BASE_RANGE = BASE_MAX - BASE_MIN;

  // ======= ZOOMED VIEW (DISPLAY ONLY; STILL 1:1) =======
  let view = { cx: 0, cy: 0, range: BASE_RANGE };
  const MIN_RANGE = 4;

  // ======= CHECK LOCKOUT =======
  const DISABLE_MS = 60_000;

  // ======= REGION MASK SETTINGS =======
  const R_N = 420;
  const BOUNDARY_THICK = 2;
  const MAX_REGIONS_ALLOWED = 12;

  // ======= STATE =======
  let mode = 0;
  let level = 1;
  let ineqs = [];
  let shapes = [];
  let regionId = null;
  let regionCount = 0;
  let regionRep = [];
  let truthRegions = new Set();
  let selected = new Set();
  let disableTimer = null;
  let failChecks = 0; // counts incorrect checks in current question

  // ======= OFFSCREEN CANVASES =======
  const maskCv = document.createElement('canvas');
  maskCv.width = maskCv.height = R_N;
  const maskCtx = maskCv.getContext('2d');

  const fillCv = document.createElement('canvas');
  fillCv.width = fillCv.height = R_N;
  const fillCtx = fillCv.getContext('2d');
  let fillImg = fillCtx.createImageData(R_N, R_N);

  // ======= DOM =======
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const levelPill = document.getElementById('levelPill');
  const modeSel = document.getElementById('modeSel');
  const modeHelp = document.getElementById('modeHelp');
  const ineqList = document.getElementById('ineqList');
  const checkBtn = document.getElementById('checkBtn');
  const clearBtn = document.getElementById('clearBtn');
  const newBtn = document.getElementById('newBtn');
  const statusBox = document.getElementById('statusBox');
  const hintBox = document.getElementById('hintBox');
  const timerPill = document.getElementById('timerPill');
  const zoomPill = document.getElementById('zoomPill');
  const after2Box = document.getElementById('after2Box');
  const tryAgainBtn = document.getElementById('tryAgainBtn');
  const showAnsBtn = document.getElementById('showAnsBtn');

  // ======= UTILS =======
  const rnd = (a,b)=>a + Math.random()*(b-a);
  const pick = arr => arr[(Math.random()*arr.length)|0];
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const randSlope = ()=> pick([-3,-2,-1.5,-1,-0.5,0.5,1,1.5,2,3]); // avoid 0 to reduce degenerate regions

  function niceNum(x){
    const r1 = Math.round(x);
    if (Math.abs(x-r1) < 1e-9) return String(r1);
    const r10 = Math.round(x*10)/10;
    if (Math.abs(x-r10) < 1e-9) return String(r10);
    return String(Math.round(x*100)/100);
  }

  function showStatus(text, kind=""){
    statusBox.style.display = "block";
    statusBox.className = "msg" + (kind ? ` ${kind}` : "");
    statusBox.textContent = text;
  }
  function showHint(text){ hintBox.style.display="block"; hintBox.textContent=text; }
  function hideHint(){ hintBox.style.display="none"; hintBox.textContent=""; }
  function enableCheck(on){ checkBtn.disabled=!on; timerPill.style.display=on?"none":"inline-flex"; }
  function hideAfter2(){ after2Box.style.display="none"; }
  function showAfter2(){ after2Box.style.display="block"; }
  function clearCooldown(){
    if (disableTimer){ clearInterval(disableTimer); disableTimer=null; }
    enableCheck(true);
    timerPill.textContent="Check available";
  }
  function startDisableCountdown(){
    const start = Date.now();
    enableCheck(false);
    if (disableTimer) clearInterval(disableTimer);
    const tick = () => {
      const left = Math.max(0, DISABLE_MS - (Date.now()-start));
      timerPill.textContent = `Check available in ${Math.ceil(left/1000)}s`;
      if (left<=0){
        clearInterval(disableTimer); disableTimer=null;
        enableCheck(true);
        showHint("You can check again now."); setTimeout(hideHint, 1200);
      }
    };
    tick();
    disableTimer = setInterval(tick, 200);
  }

  // ======= VIEW MAPPING (1:1) =======
  function viewBounds(){
    const half = view.range/2;
    return { xmin: view.cx-half, xmax: view.cx+half, ymin: view.cy-half, ymax: view.cy+half };
  }
  function plotSquare(){
    const w=cv.width, h=cv.height;
    const s=Math.min(w,h);
    return { s, ox:(w-s)/2, oy:(h-s)/2 };
  }
  function worldToCanvas(x,y){
    const {s,ox,oy}=plotSquare();
    const {xmin,xmax,ymin,ymax} = viewBounds();
    const sx = (x - xmin) / (xmax - xmin);
    const sy = (y - ymin) / (ymax - ymin);
    return { X: ox + sx*s, Y: oy + (1-sy)*s };
  }
  function canvasToWorld(X,Y){
    const {s,ox,oy}=plotSquare();
    const nx = (X - ox)/s;
    const ny = (Y - oy)/s;
    const {xmin,xmax,ymin,ymax} = viewBounds();
    const x = xmin + clamp(nx,0,1)*(xmax-xmin);
    const y = ymin + (1-clamp(ny,0,1))*(ymax-ymin);
    return {x,y};
  }

  // ======= MASK MAPPING (BASE coords always) =======
  function worldToMask(x,y){
    const sx = (x - BASE_MIN) / BASE_RANGE;
    const sy = (y - BASE_MIN) / BASE_RANGE;
    const mx = Math.floor(clamp(sx,0,1) * (R_N-1));
    const my = Math.floor((1 - clamp(sy,0,1)) * (R_N-1));
    return {mx,my};
  }
  function maskToWorld(mx,my){
    const sx = mx/(R_N-1);
    const sy = 1 - my/(R_N-1);
    return { x: BASE_MIN + sx*BASE_RANGE, y: BASE_MIN + sy*BASE_RANGE };
  }

  // ======= TeX helpers for Mode 6 + roman i/e =======
  function texPiFracFromK(kOverPi){
    const sign = kOverPi < 0 ? "-" : "";
    const a = Math.abs(kOverPi);
    let best = {num:0, den:1, err:1e9};
    for (let den=1; den<=12; den++){
      const num = Math.round(a*den);
      const err = Math.abs(a - num/den);
      if (err < best.err) best = {num,den,err};
    }
    const {num,den} = best;
    if (num===0) return "0";
    if (den===1){
      if (num===1) return `${sign}\\pi`;
      return `${sign}${num}\\pi`;
    }
    if (num===1) return `${sign}\\frac{\\pi}{${den}}`;
    return `${sign}\\frac{${num}\\pi}{${den}}`;
  }

  function texCoeffI(imAbs){
    // imAbs >= 0
    if (Math.abs(imAbs-1)<1e-9) return `\\mathrm{i}`;
    return `${niceNum(imAbs)}\\mathrm{i}`;
  }

  // returns "z-2-\\mathrm{i}" style (no extra brackets, no "(2+i)")
  function texZMinusA_plain(re, im){
    const r = Math.round(re*2)/2;
    const i = Math.round(im*2)/2;
    let out = "z";

    // subtract re
    if (Math.abs(r) > 1e-9){
      if (r > 0) out += `-${niceNum(r)}`;
      else out += `+${niceNum(Math.abs(r))}`;
    }

    // subtract im*i
    if (Math.abs(i) > 1e-9){
      const imAbs = Math.abs(i);
      const term = texCoeffI(imAbs);
      // z - (a+bi): subtracting +bi gives "-bi"; subtracting -bi gives "+bi"
      if (i > 0) out += `-${term}`;
      else out += `+${term}`;
    }

    return out;
  }

  // ======= INEQUALITIES =======
  function makeIneqVertical(a,dir){
    return { labelTex(){return `x ${dir} ${niceNum(a)}`;}, eval(x,y){return (dir==">")?(x>a+1e-9):(x<a-1e-9);} };
  }
  function makeIneqHorizontal(b,dir){
    return { labelTex(){return `y ${dir} ${niceNum(b)}`;}, eval(x,y){return (dir==">")?(y>b+1e-9):(y<b-1e-9);} };
  }
  function makeIneqLine(m,c,dir){
    return {
      labelTex(){
        const mStr = (Math.abs(m-1)<1e-9) ? "" : (Math.abs(m+1)<1e-9) ? "-" : niceNum(m);
        const xPart = (mStr==="")?"x":(mStr==="-")?"-x":`${mStr}x`;
        const c0 = Math.abs(c) < 1e-9 ? 0 : c;
        if (c0===0) return `y ${dir} ${xPart}`;
        return `y ${dir} ${xPart} ${c0>=0?"+":"-"} ${niceNum(Math.abs(c0))}`;
      },
      eval(x,y){ const rhs=m*x+c; return (dir==">")?(y>rhs+1e-9):(y<rhs-1e-9); }
    };
  }

  function makeIneqParabolaFromVertex(a,h,k,dir){
    // y ? a(x-h)^2 + k, expanded for display
    const b = -2*a*h;
    const c = a*h*h + k;
    return {
      labelTex(){
        // y ? ax^2 + bx + c
        const parts=[];
        const add=(coef,tex)=>{
          if (Math.abs(coef)<1e-9) return;
          const s=coef>=0?"+":"-";
          const mag=Math.abs(coef);
          const coefTex=(Math.abs(mag-1)<1e-9)?"":niceNum(mag);
          parts.push({s,t:`${coefTex}${tex}`});
        };
        add(a,"x^2"); add(b,"x"); add(c,"");
        let out="";
        parts.forEach((p,i)=>{ out += (i===0 ? (p.s==="-"?"-":"")+p.t : ` ${p.s} ${p.t}`); });
        if (!out) out="0";
        return `y ${dir} ${out}`;
      },
      eval(x,y){
        const rhs = a*(x-h)*(x-h) + k;
        return (dir==">")?(y>rhs+1e-9):(y<rhs-1e-9);
      }
    };
  }

  function makeIneqCubic(a,b,c,d,dir){
    return {
      labelTex(){
        const parts=[];
        const add=(coef,tex)=>{
          if (Math.abs(coef)<1e-9) return;
          const s=coef>=0?"+":"-";
          const mag=Math.abs(coef);
          const coefTex=(Math.abs(mag-1)<1e-9)?"":niceNum(mag);
          parts.push({s,t:`${coefTex}${tex}`});
        };
        add(a,"x^3"); add(b,"x^2"); add(c,"x"); add(d,"");
        if (!parts.length) parts.push({s:"+",t:"0"});
        let out="";
        parts.forEach((p,i)=>{ out += (i===0 ? (p.s==="-"?"-":"")+p.t : ` ${p.s} ${p.t}`); });
        return `y ${dir} ${out}`;
      },
      eval(x,y){ const rhs=a*x*x*x+b*x*x+c*x+d; return (dir==">")?(y>rhs+1e-9):(y<rhs-1e-9); }
    };
  }

  function makeIneqSine(A,B,C,D,dir){
    return {
      labelTex(){ return `y ${dir} ${niceNum(A)} + ${niceNum(B)}\\sin\\!\\left(${niceNum(C)}x + ${niceNum(D)}\\right)`; },
      eval(x,y){ const rhs=A+B*Math.sin(C*x+D); return (dir==">")?(y>rhs+1e-9):(y<rhs-1e-9); }
    };
  }

  // Mode 5: use bases not just e; if e used, roman e (\mathrm{e})
  function makeIneqExpBase(A,B,base,C,dir){
    const isE = (base === "e");
    return {
      labelTex(){
        const baseTex = isE ? "\\mathrm{e}" : String(base);
        return `y ${dir} ${niceNum(A)} + ${niceNum(B)}\\,${baseTex}^{${niceNum(C)}x}`;
      },
      eval(x,y){
        const pow = isE ? Math.exp(C*x) : Math.pow(Number(base), C*x);
        const rhs = A + B*pow;
        return (dir==">")?(y>rhs+1e-9):(y<rhs-1e-9);
      }
    };
  }

  // Mode 6 (no extra brackets, roman i)
  function makeIneqCircle(cx,cy,r,dir){
    return {
      labelTex(){ return `\\left|${texZMinusA_plain(cx,cy)}\\right| ${dir} ${niceNum(r)}`; },
      eval(x,y){
        const d=Math.hypot(x-cx,y-cy);
        return (dir==">")?(d>r+1e-9):(d<r-1e-9);
      }
    };
  }
  function makeIneqArgBetween(cx,cy,lo,hi){
    return {
      labelTex(){
        return `${texPiFracFromK(lo/Math.PI)} < \\arg\\!\\left(${texZMinusA_plain(cx,cy)}\\right) < ${texPiFracFromK(hi/Math.PI)}`;
      },
      eval(x,y){
        const ang=Math.atan2(y-cy,x-cx);
        return ang>lo+1e-9 && ang<hi-1e-9;
      }
    };
  }
  function makeIneqBisector(ax,ay,bx,by,dir){
    return {
      labelTex(){
        return `\\left|${texZMinusA_plain(ax,ay)}\\right| ${dir} \\left|${texZMinusA_plain(bx,by)}\\right|`;
      },
      eval(x,y){
        const da=Math.hypot(x-ax,y-ay);
        const db=Math.hypot(x-bx,y-by);
        return (dir==">")?(da>db+1e-9):(da<db-1e-9);
      }
    };
  }

  // ======= SHAPES (BOUNDARIES) =======
  function shapeLine(m,c){
    return {
      drawWorld(){
        const pts=[];
        for (const x of [BASE_MIN,BASE_MAX]){
          const y=m*x+c;
          if (y>=BASE_MIN-1e-9 && y<=BASE_MAX+1e-9) pts.push({x,y});
        }
        if (Math.abs(m)>1e-12){
          for (const y of [BASE_MIN,BASE_MAX]){
            const x=(y-c)/m;
            if (x>=BASE_MIN-1e-9 && x<=BASE_MAX+1e-9) pts.push({x,y});
          }
        }
        let A=null,B=null;
        for (let i=0;i<pts.length;i++){
          for (let j=i+1;j<pts.length;j++){
            if (Math.hypot(pts[i].x-pts[j].x,pts[i].y-pts[j].y)>1e-6){A=pts[i];B=pts[j];break;}
          }
          if (A) break;
        }
        if (!A||!B) return;
        const pA=worldToCanvas(A.x,A.y), pB=worldToCanvas(B.x,B.y);
        ctx.beginPath(); ctx.moveTo(pA.X,pA.Y); ctx.lineTo(pB.X,pB.Y); ctx.stroke();
      },
      drawMask(){
        const pts=[];
        for (const x of [BASE_MIN,BASE_MAX]){
          const y=m*x+c;
          if (y>=BASE_MIN-1e-9 && y<=BASE_MAX+1e-9) pts.push({x,y});
        }
        if (Math.abs(m)>1e-12){
          for (const y of [BASE_MIN,BASE_MAX]){
            const x=(y-c)/m;
            if (x>=BASE_MIN-1e-9 && x<=BASE_MAX+1e-9) pts.push({x,y});
          }
        }
        let A=null,B=null;
        for (let i=0;i<pts.length;i++){
          for (let j=i+1;j<pts.length;j++){
            if (Math.hypot(pts[i].x-pts[j].x,pts[i].y-pts[j].y)>1e-6){A=pts[i];B=pts[j];break;}
          }
          if (A) break;
        }
        if (!A||!B) return;
        const pA=worldToMask(A.x,A.y), pB=worldToMask(B.x,B.y);
        maskCtx.beginPath(); maskCtx.moveTo(pA.mx+0.5,pA.my+0.5); maskCtx.lineTo(pB.mx+0.5,pB.my+0.5); maskCtx.stroke();
      }
    };
  }
  function shapeVertical(a){
    return {
      drawWorld(){
        const p1=worldToCanvas(a,BASE_MIN), p2=worldToCanvas(a,BASE_MAX);
        ctx.beginPath(); ctx.moveTo(p1.X,p1.Y); ctx.lineTo(p2.X,p2.Y); ctx.stroke();
      },
      drawMask(){
        const p1=worldToMask(a,BASE_MIN), p2=worldToMask(a,BASE_MAX);
        maskCtx.beginPath(); maskCtx.moveTo(p1.mx+0.5,p1.my+0.5); maskCtx.lineTo(p2.mx+0.5,p2.my+0.5); maskCtx.stroke();
      }
    };
  }
  function shapeHorizontal(b){
    return {
      drawWorld(){
        const p1=worldToCanvas(BASE_MIN,b), p2=worldToCanvas(BASE_MAX,b);
        ctx.beginPath(); ctx.moveTo(p1.X,p1.Y); ctx.lineTo(p2.X,p2.Y); ctx.stroke();
      },
      drawMask(){
        const p1=worldToMask(BASE_MIN,b), p2=worldToMask(BASE_MAX,b);
        maskCtx.beginPath(); maskCtx.moveTo(p1.mx+0.5,p1.my+0.5); maskCtx.lineTo(p2.mx+0.5,p2.my+0.5); maskCtx.stroke();
      }
    };
  }
  function shapeGraph(fn){
    return {
      drawWorld(){
        const steps=900;
        let started=false;
        for (let i=0;i<=steps;i++){
          const x=BASE_MIN+(BASE_MAX-BASE_MIN)*(i/steps);
          const y=fn(x);
          if (!Number.isFinite(y)){ started=false; continue; }
          const p=worldToCanvas(x,y);
          if (!started){ ctx.beginPath(); ctx.moveTo(p.X,p.Y); started=true; }
          else ctx.lineTo(p.X,p.Y);
        }
        if (started) ctx.stroke();
      },
      drawMask(){
        const steps=900;
        let started=false;
        for (let i=0;i<=steps;i++){
          const x=BASE_MIN+(BASE_MAX-BASE_MIN)*(i/steps);
          const y=fn(x);
          if (!Number.isFinite(y)){ started=false; continue; }
          const p=worldToMask(x,y);
          if (!started){ maskCtx.beginPath(); maskCtx.moveTo(p.mx+0.5,p.my+0.5); started=true; }
          else maskCtx.lineTo(p.mx+0.5,p.my+0.5);
        }
        if (started) maskCtx.stroke();
      }
    };
  }
  function shapeCircle(cx,cy,r){
    return {
      drawWorld(){
        const steps=720;
        ctx.beginPath();
        for (let i=0;i<=steps;i++){
          const t=(i/steps)*Math.PI*2;
          const x=cx+r*Math.cos(t);
          const y=cy+r*Math.sin(t);
          const p=worldToCanvas(x,y);
          if (i===0) ctx.moveTo(p.X,p.Y); else ctx.lineTo(p.X,p.Y);
        }
        ctx.stroke();
      },
      drawMask(){
        const steps=720;
        maskCtx.beginPath();
        for (let i=0;i<=steps;i++){
          const t=(i/steps)*Math.PI*2;
          const x=cx+r*Math.cos(t);
          const y=cy+r*Math.sin(t);
          const p=worldToMask(x,y);
          if (i===0) maskCtx.moveTo(p.mx+0.5,p.my+0.5); else maskCtx.lineTo(p.mx+0.5,p.my+0.5);
        }
        maskCtx.stroke();
      }
    };
  }
  function shapeRay(cx,cy,theta){
    return {
      drawWorld(){
        const dx=Math.cos(theta), dy=Math.sin(theta);
        const ts=[];
        if (Math.abs(dx)>1e-12){
          for (const X of [BASE_MIN,BASE_MAX]){
            const t=(X-cx)/dx;
            const y=cy+t*dy;
            if (t>=0 && y>=BASE_MIN-1e-9 && y<=BASE_MAX+1e-9) ts.push(t);
          }
        }
        if (Math.abs(dy)>1e-12){
          for (const Y of [BASE_MIN,BASE_MAX]){
            const t=(Y-cy)/dy;
            const x=cx+t*dx;
            if (t>=0 && x>=BASE_MIN-1e-9 && x<=BASE_MAX+1e-9) ts.push(t);
          }
        }
        if (!ts.length) return;
        const tMax=Math.max(...ts);
        const pA=worldToCanvas(cx,cy), pB=worldToCanvas(cx+tMax*dx, cy+tMax*dy);
        ctx.beginPath(); ctx.moveTo(pA.X,pA.Y); ctx.lineTo(pB.X,pB.Y); ctx.stroke();
      },
      drawMask(){
        const dx=Math.cos(theta), dy=Math.sin(theta);
        const ts=[];
        if (Math.abs(dx)>1e-12){
          for (const X of [BASE_MIN,BASE_MAX]){
            const t=(X-cx)/dx;
            const y=cy+t*dy;
            if (t>=0 && y>=BASE_MIN-1e-9 && y<=BASE_MAX+1e-9) ts.push(t);
          }
        }
        if (Math.abs(dy)>1e-12){
          for (const Y of [BASE_MIN,BASE_MAX]){
            const t=(Y-cy)/dy;
            const x=cx+t*dx;
            if (t>=0 && x>=BASE_MIN-1e-9 && x<=BASE_MAX+1e-9) ts.push(t);
          }
        }
        if (!ts.length) return;
        const tMax=Math.max(...ts);
        const pA=worldToMask(cx,cy), pB=worldToMask(cx+tMax*dx, cy+tMax*dy);
        maskCtx.beginPath(); maskCtx.moveTo(pA.mx+0.5,pA.my+0.5); maskCtx.lineTo(pB.mx+0.5,pB.my+0.5); maskCtx.stroke();
      }
    };
  }

  // ======= MASK → REGIONS =======
  function drawMaskBoundaries(){
    maskCtx.fillStyle="#fff";
    maskCtx.fillRect(0,0,R_N,R_N);
    maskCtx.strokeStyle="#000";
    maskCtx.lineWidth=Math.max(1,BOUNDARY_THICK);
    maskCtx.strokeRect(0.5,0.5,R_N-1,R_N-1);
    for (const s of shapes) s.drawMask();
  }
  function buildRegionsFromMask(){
    const img = maskCtx.getImageData(0,0,R_N,R_N).data;
    regionId = new Int32Array(R_N*R_N);
    regionRep = [];
    regionCount = 0;
    const idxPix=(x,y)=>4*(y*R_N+x);
    const idxCell=(x,y)=>y*R_N+x;
    const isBoundary=(p)=>(img[p]+img[p+1]+img[p+2]) < 60*3;
    const qx = new Int32Array(R_N*R_N);
    const qy = new Int32Array(R_N*R_N);

    for (let y=0;y<R_N;y++){
      for (let x=0;x<R_N;x++){
        const cell=idxCell(x,y);
        if (regionId[cell]!==0) continue;
        if (isBoundary(idxPix(x,y))) continue;

        regionCount++;
        const rid=regionCount;
        let head=0, tail=0;
        qx[tail]=x; qy[tail]=y; tail++;
        regionId[cell]=rid;
        regionRep[rid]={mx:x,my:y};

        while (head<tail){
          const cx0=qx[head], cy0=qy[head]; head++;
          const neigh=[[cx0+1,cy0],[cx0-1,cy0],[cx0,cy0+1],[cx0,cy0-1]];
          for (const [nx,ny] of neigh){
            if (nx<0||nx>=R_N||ny<0||ny>=R_N) continue;
            const ccell=idxCell(nx,ny);
            if (regionId[ccell]!==0) continue;
            if (isBoundary(idxPix(nx,ny))) continue;
            regionId[ccell]=rid;
            qx[tail]=nx; qy[tail]=ny; tail++;
          }
        }
      }
    }
  }
  function computeTruthRegions(){
    truthRegions = new Set();
    for (let rid=1; rid<=regionCount; rid++){
      const rep=regionRep[rid];
      if (!rep) continue;
      const {x,y}=maskToWorld(rep.mx,rep.my);
      let ok=true;
      for (const inq of ineqs){
        if (!inq.eval(x,y)){ ok=false; break; }
      }
      if (ok) truthRegions.add(rid);
    }
  }

  function rebuildFillOverlay(){
    const d=fillImg.data;
    for (let i=0;i<d.length;i+=4){ d[i]=0; d[i+1]=0; d[i+2]=0; d[i+3]=0; }
    for (let y=0;y<R_N;y++){
      for (let x=0;x<R_N;x++){
        const rid=regionId[y*R_N+x];
        if (rid<=0 || !selected.has(rid)) continue;
        const k=4*(y*R_N+x);
        d[k]=249; d[k+1]=115; d[k+2]=22; d[k+3]=56;
      }
    }
    fillCtx.putImageData(fillImg,0,0);
  }

  // ======= DRAWING =======
  function drawAxesTicks(){
    const {s,ox,oy}=plotSquare();

    ctx.lineWidth=2.0;
    ctx.strokeStyle="rgba(17,24,39,0.35)";
    ctx.strokeRect(ox,oy,s,s);

    ctx.strokeStyle="rgba(17,24,39,0.35)";
    ctx.lineWidth=2.1;
    const p0 = worldToCanvas(0,0);
    ctx.beginPath(); ctx.moveTo(p0.X, oy); ctx.lineTo(p0.X, oy+s); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ox, p0.Y); ctx.lineTo(ox+s, p0.Y); ctx.stroke();

    ctx.fillStyle="rgba(17,24,39,0.70)";
    ctx.font="14px system-ui,-apple-system,Segoe UI,Roboto,Arial";

    ctx.textAlign="center"; ctx.textBaseline="top";
    for (let x=-12;x<=12;x+=2){
      const p=worldToCanvas(x,0);
      if (p.X < ox-2 || p.X > ox+s+2) continue;
      ctx.beginPath();
      ctx.strokeStyle="rgba(17,24,39,0.25)";
      ctx.lineWidth=1.5;
      ctx.moveTo(p.X,p0.Y-6); ctx.lineTo(p.X,p0.Y+6); ctx.stroke();
      if (x!==0) ctx.fillText(String(x), p.X, p0.Y+10);
    }

    ctx.textAlign="right"; ctx.textBaseline="middle";
    for (let y=-12;y<=12;y+=2){
      const p=worldToCanvas(0,y);
      if (p.Y < oy-2 || p.Y > oy+s+2) continue;
      ctx.beginPath();
      ctx.strokeStyle="rgba(17,24,39,0.25)";
      ctx.lineWidth=1.5;
      ctx.moveTo(p0.X-6,p.Y); ctx.lineTo(p0.X+6,p.Y); ctx.stroke();
      if (y!==0) ctx.fillText(String(y), p0.X-10, p.Y);
    }
  }

  function drawFillOverlayInView(){
    // draw fill overlay cropped to view bounds, and only inside plot square
    const {s,ox,oy}=plotSquare();
    const b=viewBounds();

    const sx0 = ((b.xmin - BASE_MIN) / BASE_RANGE) * (R_N-1);
    const sx1 = ((b.xmax - BASE_MIN) / BASE_RANGE) * (R_N-1);
    const sy0 = (1 - ((b.ymax - BASE_MIN) / BASE_RANGE)) * (R_N-1);
    const sy1 = (1 - ((b.ymin - BASE_MIN) / BASE_RANGE)) * (R_N-1);

    const sx = clamp(Math.min(sx0,sx1), 0, R_N-1);
    const sy = clamp(Math.min(sy0,sy1), 0, R_N-1);
    const sw = clamp(Math.abs(sx1-sx0), 1, R_N-1);
    const sh = clamp(Math.abs(sy1-sy0), 1, R_N-1);

    ctx.drawImage(fillCv, sx, sy, sw, sh, ox, oy, s, s);
  }

  function drawAll(){
    const w=cv.width,h=cv.height;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,w,h);

    drawFillOverlayInView();

    ctx.strokeStyle="rgba(17,24,39,0.55)";
    ctx.lineWidth=2.8;
    for (const s of shapes) s.drawWorld();

    drawAxesTicks();
  }

  // ======= INEQUALITY LIST (MathJax) =======
  function renderIneqList(){
    levelPill.textContent = `Level ${level} / 6`;
    ineqList.innerHTML = "";
    ineqs.forEach((inq,i)=>{
      const d=document.createElement("div");
      d.className="ineq";
      d.innerHTML = `<div class="k">Inequality ${i+1}</div><div class="v">\\(${inq.labelTex()}\\)</div>`;
      ineqList.appendChild(d);
    });
    if (window.MathJax?.typesetPromise){
      MathJax.typesetClear?.([ineqList]);
      MathJax.typesetPromise([ineqList]).catch(()=>{});
    }
  }

  function modeDescription(m){
    return [
      "Mode 0: only vertical/horizontal lines x=a or y=b.",
      "Mode 1: exactly one inequality of the form x>a or x<a.",
      "Mode 2: lines + parabolas (Level 1 uses a parabola with turning point within −8 to 8).",
      "Mode 3: lines + parabolas + cubics (includes positive and negative leading cubics).",
      "Mode 4: lines + sine waves (Level 1 uses a sine wave).",
      "Mode 5: lines + exponentials with various bases (including e, shown upright).",
      "Mode 6: complex loci (i is upright; no extra brackets like z-(2+i))."
    ][m] || "";
  }

  // ======= GENERATION (constraints) =======
  function randomVertexWithin(){
    // h,k in [-8,8] (with halves)
    const h = Math.round(rnd(-8,8)*2)/2;
    const k = Math.round(rnd(-8,8)*2)/2;
    return {h,k};
  }

  function generateMode0(k){
    shapes=[]; const pool=[];
    for (let i=0;i<3;i++){
      if (Math.random()<0.5){
        const a=Math.round(rnd(-9,9)*2)/2;
        shapes.push(shapeVertical(a));
        pool.push(()=>makeIneqVertical(a, Math.random()<0.5?">":"<"));
      } else {
        const b=Math.round(rnd(-9,9)*2)/2;
        shapes.push(shapeHorizontal(b));
        pool.push(()=>makeIneqHorizontal(b, Math.random()<0.5?">":"<"));
      }
    }
    const d=Math.round(rnd(-9,9)*2)/2;
    shapes.push(Math.random()<0.5 ? shapeVertical(d) : shapeHorizontal(d));
    ineqs=[];
    for (let i=0;i<k;i++) ineqs.push(pool[i % pool.length]());
  }

  function generateMode1(){
    shapes=[];
    const a=Math.round(rnd(-9,9)*2)/2;
    shapes.push(shapeVertical(a));
    for (let i=0;i<2;i++){
      const m=randSlope();
      const c=Math.round(rnd(-7,7)*2)/2;
      shapes.push(shapeLine(m,c));
    }
    ineqs=[makeIneqVertical(a, Math.random()<0.5?">":"<")];
  }

  function generateMode2(k){
    shapes=[]; const pool=[];

    // first inequality MUST be parabola; vertex within [-8,8]x[-8,8]
    const a = pick([-1.5,-1,-0.5,0.5,1,1.5]);
    const {h,k0} = randomVertexWithin();
    shapes.push(shapeGraph(x=>a*(x-h)*(x-h) + k0));
    pool.push(()=>makeIneqParabolaFromVertex(a,h,k0, Math.random()<0.5?">":"<"));

    // add lines
    for (let i=0;i<3;i++){
      const m=randSlope();
      const c=Math.round(rnd(-7,7)*2)/2;
      shapes.push(shapeLine(m,c));
      pool.push(()=>makeIneqLine(m,c, Math.random()<0.5?">":"<"));
    }

    shapes.push(shapeLine(randSlope(), Math.round(rnd(-7,7)*2)/2));

    ineqs=[];
    for (let i=0;i<k;i++) ineqs.push(pool[i]());
  }

  function generateMode3(k){
    shapes=[]; const pool=[];

    // first inequality MUST be cubic; include pos/neg leading coefficients
    const a = (Math.random()<0.5 ? 1 : -1) * pick([0.1,0.15,0.2]);
    const b = Math.round(rnd(-1.5,1.5)*2)/2;
    const c = Math.round(rnd(-2,2)*2)/2;
    const d = Math.round(rnd(-4,4)*2)/2;
    shapes.push(shapeGraph(x=>a*x*x*x + b*x*x + c*x + d));
    pool.push(()=>makeIneqCubic(a,b,c,d, Math.random()<0.5?">":"<"));

    // add a parabola
    const ap = pick([-1.5,-1,-0.5,0.5,1,1.5]);
    const {h,k0} = randomVertexWithin();
    shapes.push(shapeGraph(x=>ap*(x-h)*(x-h) + k0));
    pool.push(()=>makeIneqParabolaFromVertex(ap,h,k0, Math.random()<0.5?">":"<"));

    // add 2 lines
    for (let i=0;i<2;i++){
      const m=randSlope();
      const cc=Math.round(rnd(-7,7)*2)/2;
      shapes.push(shapeLine(m,cc));
      pool.push(()=>makeIneqLine(m,cc, Math.random()<0.5?">":"<"));
    }

    shapes.push(shapeLine(randSlope(), Math.round(rnd(-7,7)*2)/2));

    ineqs=[];
    for (let i=0;i<k;i++) ineqs.push(pool[i]());
  }

  function generateMode4(k){
    shapes=[]; const pool=[];

    // first inequality MUST be sine
    const A=Math.round(rnd(-3,3)*2)/2;
    const B=pick([1,1.5,2,2.5])*(Math.random()<0.5?-1:1);
    const C=pick([0.5,1,1.5,2]);
    const D=Math.round(rnd(-Math.PI,Math.PI)*100)/100;
    shapes.push(shapeGraph(x=>A + B*Math.sin(C*x + D)));
    pool.push(()=>makeIneqSine(A,B,C,D, Math.random()<0.5?">":"<"));

    for (let i=0;i<3;i++){
      const m=randSlope();
      const cc=Math.round(rnd(-7,7)*2)/2;
      shapes.push(shapeLine(m,cc));
      pool.push(()=>makeIneqLine(m,cc, Math.random()<0.5?">":"<"));
    }

    shapes.push(shapeLine(randSlope(), Math.round(rnd(-7,7)*2)/2));

    ineqs=[];
    for (let i=0;i<k;i++) ineqs.push(pool[i]());
  }

  function generateMode5(k){
    shapes=[]; const pool=[];

    // first inequality MUST be exponential with varied bases
    const A=Math.round(rnd(-3,3)*2)/2;
    const B=pick([0.5,1,1.5,2])*(Math.random()<0.5?-1:1);
    const base = pick([2,3,5,10,"e"]);
    const C=pick([0.1,0.15,0.2,0.25,0.3])*(Math.random()<0.5?-1:1);
    shapes.push(shapeGraph(x=>{
      const pow = (base==="e") ? Math.exp(C*x) : Math.pow(Number(base), C*x);
      return A + B*pow;
    }));
    pool.push(()=>makeIneqExpBase(A,B,base,C, Math.random()<0.5?">":"<"));

    for (let i=0;i<3;i++){
      const m=randSlope();
      const cc=Math.round(rnd(-7,7)*2)/2;
      shapes.push(shapeLine(m,cc));
      pool.push(()=>makeIneqLine(m,cc, Math.random()<0.5?">":"<"));
    }

    shapes.push(shapeLine(randSlope(), Math.round(rnd(-7,7)*2)/2));

    ineqs=[];
    for (let i=0;i<k;i++) ineqs.push(pool[i]());
  }

  function randomPiAngle(){
    const steps=[-5/6,-3/4,-2/3,-1/2,-1/3,-1/4,-1/5,-1/6, 0, 1/6,1/5,1/4,1/3,1/2,2/3,3/4,5/6];
    return pick(steps)*Math.PI;
  }

  function generateMode6(k){
    shapes=[]; ineqs=[];
    const loci=[];
    for (let i=0;i<6;i++){
      const t=Math.random();
      if (t < 0.38){
        const cx=Math.round(rnd(-6,6)*2)/2;
        const cy=Math.round(rnd(-6,6)*2)/2;
        const r=Math.round(rnd(1.5,5)*2)/2;
        const dir=Math.random()<0.5?">":"<";
        loci.push({type:"circle", cx,cy,r,dir});
      } else if (t < 0.68){
        const cx=Math.round(rnd(-4,4)*2)/2;
        const cy=Math.round(rnd(-4,4)*2)/2;
        let lo=randomPiAngle();
        let hi=randomPiAngle();
        if (lo>hi){ const tmp=lo; lo=hi; hi=tmp; }
        if (hi-lo < Math.PI/8){
          hi = lo + Math.PI/4;
          if (hi > Math.PI - Math.PI/12) hi = Math.PI - Math.PI/12;
        }
        loci.push({type:"argBetween", cx,cy,lo,hi});
      } else {
        const ax=Math.round(rnd(-7,7)*2)/2;
        const ay=Math.round(rnd(-7,7)*2)/2;
        let bx=Math.round(rnd(-7,7)*2)/2;
        let by=Math.round(rnd(-7,7)*2)/2;
        if (Math.hypot(ax-bx,ay-by) < 2){ bx += 3; by -= 2; }
        const dir=Math.random()<0.5?">":"<";
        loci.push({type:"bisector", ax,ay,bx,by,dir});
      }
    }

    // boundaries from all 6 loci
    for (const L of loci){
      if (L.type==="circle"){
        shapes.push(shapeCircle(L.cx,L.cy,L.r));
      } else if (L.type==="argBetween"){
        shapes.push(shapeRay(L.cx,L.cy,L.lo));
        shapes.push(shapeRay(L.cx,L.cy,L.hi));
      } else {
        const vx=(L.bx-L.ax), vy=(L.by-L.ay);
        const rhs=(L.bx*L.bx+L.by*L.by)-(L.ax*L.ax+L.ay*L.ay);
        if (Math.abs(vy) > 1e-9){
          shapes.push(shapeLine((-vx)/vy, (rhs/2)/vy));
        } else {
          shapes.push(shapeVertical((rhs/2)/vx));
        }
      }
    }

    // pick k inequalities
    const idxs=[0,1,2,3,4,5];
    for (let i=idxs.length-1;i>0;i--){
      const j=(Math.random()*(i+1))|0;
      [idxs[i],idxs[j]]=[idxs[j],idxs[i]];
    }
    const chosen=idxs.slice(0,k).map(i=>loci[i]);
    for (const L of chosen){
      if (L.type==="circle") ineqs.push(makeIneqCircle(L.cx,L.cy,L.r,L.dir));
      else if (L.type==="argBetween") ineqs.push(makeIneqArgBetween(L.cx,L.cy,L.lo,L.hi));
      else ineqs.push(makeIneqBisector(L.ax,L.ay,L.bx,L.by,L.dir));
    }
  }

  function generateForModeAndLevel(){
    const targetK = (mode===1) ? 1 : level;
    const MAX_TRIES=700;

    for (let t=0;t<MAX_TRIES;t++){
      if (mode===0) generateMode0(targetK);
      else if (mode===1) generateMode1();
      else if (mode===2) generateMode2(targetK);
      else if (mode===3) generateMode3(targetK);
      else if (mode===4) generateMode4(targetK);
      else if (mode===5) generateMode5(targetK);
      else if (mode===6) generateMode6(targetK);

      drawMaskBoundaries();
      buildRegionsFromMask();
      if (regionCount > MAX_REGIONS_ALLOWED) continue;

      computeTruthRegions();
      if (truthRegions.size === 0) continue;

      // each inequality alone non-empty
      let okEach=true;
      for (const inq of ineqs){
        let any=false;
        for (let rid=1; rid<=regionCount; rid++){
          const rep=regionRep[rid];
          const {x,y}=maskToWorld(rep.mx,rep.my);
          if (inq.eval(x,y)){ any=true; break; }
        }
        if (!any){ okEach=false; break; }
      }
      if (!okEach) continue;

      return true;
    }
    return false;
  }

  // ======= ROUND CONTROL =======
  function setDefaultView(){
    view = { cx:0, cy:0, range:BASE_RANGE };
    zoomPill.textContent="Zoom: 100%";
  }
  function updateZoomPill(){
    zoomPill.textContent = `Zoom: ${Math.round((BASE_RANGE/view.range)*100)}%`;
  }

  function newRound(forLevel){
    level = (mode===1) ? 1 : clamp(forLevel,1,6);
    selected.clear();
    statusBox.style.display="none";
    hideHint();
    hideAfter2();
    failChecks = 0;

    const ok = generateForModeAndLevel();
    if (!ok){
      showHint("Couldn’t generate a valid set quickly (non-empty + ≤12 regions). Press New image to try again.");
    }

    renderIneqList();
    rebuildFillOverlay();
    drawAll();
  }

  // ======= CHECK / ANSWER OPTIONS =======
  function regionAtWorld(x,y){
    const {mx,my}=worldToMask(x,y);
    return regionId ? regionId[my*R_N+mx] : 0;
  }

  function doCheck(){
    let correct=0, incorrect=0, missed=0;
    for (const rid of selected){
      if (truthRegions.has(rid)) correct++; else incorrect++;
    }
    for (const rid of truthRegions){
      if (!selected.has(rid)) missed++;
    }

    const perfect=(incorrect===0 && missed===0);
    showStatus(`${correct} regions correct, ${incorrect} regions incorrect, ${missed} regions missed.`, perfect?"good":"bad");

    if (perfect){
      failChecks = 0;
      hideAfter2();
      clearCooldown(); // timer resets when correct
      if (mode===1){
        showHint("Correct! New image generated (Mode 1)."); setTimeout(hideHint, 1000);
        newRound(1);
      } else if (level<6){
        showHint(`Correct! New set generated for Level ${level+1}.`); setTimeout(hideHint, 1000);
        newRound(level+1);
      } else {
        showHint("Correct! Level 6 complete. Press “New image” to restart.");
      }
      return;
    }

    failChecks++;
    if (failChecks >= 2){
      showAfter2();
    } else {
      hideAfter2();
    }

    showHint("Adjust your filled regions, then check again when the button unlocks.");
    startDisableCountdown();
  }

  tryAgainBtn.addEventListener('click', () => {
    hideAfter2();
    // keep their current shading; allow them to continue as normal
  });

  showAnsBtn.addEventListener('click', () => {
    // reveal by selecting exactly the truth regions
    selected = new Set(truthRegions);
    rebuildFillOverlay();
    drawAll();
    showHint("Correct regions are now filled. Press New image to continue, or Clear shading to retry.");
    setTimeout(hideHint, 2000);
  });

  // ======= INPUT (CLICK / DRAG) =======
  function getCanvasXY(evt){
    const rect=cv.getBoundingClientRect();
    const clientX = (evt.touches && evt.touches.length) ? evt.touches[0].clientX : evt.clientX;
    const clientY = (evt.touches && evt.touches.length) ? evt.touches[0].clientY : evt.clientY;
    return {
      x:(clientX-rect.left)*(cv.width/rect.width),
      y:(clientY-rect.top)*(cv.height/rect.height)
    };
  }

  let isDown=false, lastRid=null;
  function toggleAtEvent(evt){
    const p=getCanvasXY(evt);
    const w=canvasToWorld(p.x,p.y);
    const rid=regionAtWorld(w.x,w.y);
    if (!rid) return 0;
    if (selected.has(rid)) selected.delete(rid); else selected.add(rid);
    rebuildFillOverlay();
    drawAll();
    return rid;
  }
  function onDown(evt){
    evt.preventDefault();
    isDown=true;
    lastRid = toggleAtEvent(evt);
  }
  function onMove(evt){
    if (!isDown) return;
    evt.preventDefault();
    const p=getCanvasXY(evt);
    const w=canvasToWorld(p.x,p.y);
    const rid=regionAtWorld(w.x,w.y);
    if (!rid || rid===lastRid) return;
    lastRid = rid;
    if (selected.has(rid)) selected.delete(rid); else selected.add(rid);
    rebuildFillOverlay();
    drawAll();
  }
  function onUp(evt){ evt.preventDefault(); isDown=false; lastRid=null; }

  cv.addEventListener('mousedown', onDown);
  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);
  cv.addEventListener('touchstart', onDown, {passive:false});
  window.addEventListener('touchmove', onMove, {passive:false});
  window.addEventListener('touchend', onUp, {passive:false});

  // ======= ZOOM (WHEEL) =======
  cv.addEventListener('wheel', (evt)=>{
    evt.preventDefault();
    const zoomIn = evt.deltaY < 0;
    const factor = zoomIn ? 0.9 : 1.1111111111;

    const oldRange = view.range;
    let newRange = clamp(oldRange*factor, MIN_RANGE, BASE_RANGE);
    if (Math.abs(newRange-oldRange) < 1e-9) return;

    const p=getCanvasXY(evt);
    const mouseW=canvasToWorld(p.x,p.y);

    const b=viewBounds();
    const rx = (mouseW.x - b.xmin) / (b.xmax - b.xmin);
    const ry = (mouseW.y - b.ymin) / (b.ymax - b.ymin);

    const newXmin = mouseW.x - rx*newRange;
    const newYmin = mouseW.y - ry*newRange;

    view.range = newRange;
    view.cx = newXmin + newRange/2;
    view.cy = newYmin + newRange/2;

    updateZoomPill();
    drawAll();
  }, {passive:false});

  // ======= BUTTONS / MODE =======
  clearBtn.addEventListener('click', ()=>{
    selected.clear();
    rebuildFillOverlay();
    drawAll();
    showStatus("Shading cleared.", "");
    setTimeout(()=>statusBox.style.display="none", 900);
  });

  newBtn.addEventListener('click', ()=>{
    clearCooldown();
    setDefaultView();
    showHint(`New image generated for Level ${level}.`); setTimeout(hideHint, 900);
    newRound(level);
  });

  checkBtn.addEventListener('click', ()=>{ if (!checkBtn.disabled) doCheck(); });

  modeSel.addEventListener('change', ()=>{
    mode = Number(modeSel.value)||0;
    clearCooldown();
    setDefaultView();
    modeHelp.textContent = modeDescription(mode) + " (Curves not highlighted; only inequalities shown.)";
    level=1;
    showHint(modeDescription(mode)); setTimeout(hideHint, 1400);
    newRound(1);
  });

  // ======= INIT =======
  function init(){
    mode = Number(modeSel.value)||0;
    modeHelp.textContent = modeDescription(mode) + " (Curves not highlighted; only inequalities shown.)";
    enableCheck(true);
    setDefaultView();
    updateZoomPill();
    newRound(1);
  }
  window.addEventListener('load', init);
})();
</script>
</body>
</html>
