<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Region Shading (Modes 0–6)</title>

<script>
  window.MathJax = {
    tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
    options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

<style>
  :root{
    --bg:#f5f7fb; --card:#fff; --ink:#111827; --muted:#6b7280; --line:#e5e7eb;
    --accent:#f97316; --good:#16a34a; --bad:#dc2626; --warn:#d97706;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--ink)}
  header{padding:14px 16px}
  header h1{margin:0;font-size:18px}
  header p{margin:6px 0 0;color:var(--muted);font-size:13px}

  .wrap{display:grid;grid-template-columns:420px 1fr;gap:14px;padding:0 16px 16px}
  @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }

  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;box-shadow:0 8px 18px rgba(0,0,0,.05)}
  .card .hd{padding:12px 14px;border-bottom:1px solid var(--line);display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  .card .bd{padding:12px 14px}

  .btnrow{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  button{
    appearance:none;border:1px solid var(--line);background:#fff;color:var(--ink);
    padding:10px 12px;border-radius:12px;font-weight:650;cursor:pointer;
    transition:.12s; user-select:none;
  }
  button:hover{transform:translateY(-1px);box-shadow:0 10px 16px rgba(0,0,0,.06)}
  button:disabled{opacity:.55;cursor:not-allowed;transform:none;box-shadow:none}
  .primary{background:var(--accent);border-color:transparent;color:#fff}
  .pill{font-size:12px;color:var(--muted);border:1px solid var(--line);padding:6px 10px;border-radius:999px;white-space:nowrap}
  select{
    border:1px solid var(--line); border-radius:12px; padding:10px 12px;
    font-weight:650; background:#fff; color:var(--ink);
  }

  .list{display:flex;flex-direction:column;gap:10px;margin-top:10px}
  .ineq{border:1px solid var(--line);border-radius:12px;padding:10px;background:#fff}
  .ineq .k{font-size:12px;color:var(--muted);margin-bottom:6px}
  .ineq .v{font-size:18px;font-weight:850}
  .ineq .v mjx-container{ font-size: 110% !important; }

  .small{font-size:12px;color:var(--muted)}
  .msg{margin-top:10px;padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:#fafafa}
  .msg.good{border-color:rgba(22,163,74,.35);background:rgba(22,163,74,.08);color:#0f5132}
  .msg.bad{border-color:rgba(220,38,38,.35);background:rgba(220,38,38,.08);color:#7f1d1d}
  .msg.warn{border-color:rgba(217,119,6,.35);background:rgba(217,119,6,.10);color:#7c2d12}

  .canvasWrap{padding:12px}
  canvas{
    width:100%;
    aspect-ratio: 3 / 2;
    height:auto;
    max-height:560px;
    display:block;border-radius:14px;border:1px solid var(--line);background:#fff;touch-action:none
  }
  @media (max-width: 980px){ canvas{max-height:520px} }

  .choiceRow{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
</style>
</head>
<body>
<header>
  <h1>Region Shading — Multiple Modes</h1>
  <p>Click / tap inside a region to fill/unfill it (screen edge is a boundary). Select all regions where <b>all</b> inequalities are true, then press <b>Check</b>. (Axes always −12 to 12.)</p>
</header>

<div class="wrap">
  <section class="card">
    <div class="hd">
      <div class="btnrow">
        <span class="pill" id="levelPill">Level 1 / 6</span>
        <label class="pill" style="display:flex;gap:8px;align-items:center">
          Mode
          <select id="modeSel" aria-label="Mode">
            <option value="0">Mode 0: x=a and y=b only</option>
            <option value="1">Mode 1: Lines</option>
            <option value="2">Mode 2: lines + parabolas</option>
            <option value="3">Mode 3: lines + parabolas + cubics</option>
            <option value="4">Mode 4: lines + sine waves</option>
            <option value="5">Mode 5: lines + exponentials</option>
            <option value="6">Mode 6: complex loci</option>
          </select>
        </label>
      </div>
      <div class="btnrow">
        <button id="clearBtn">Clear shading</button>
        <button id="newBtn">New image</button>
      </div>
    </div>

    <div class="bd">
      <div class="small" id="modeHelp"></div>
      <div class="list" id="ineqList"></div>

      <div class="msg warn" id="hintBox" style="display:none"></div>
      <div class="msg" id="statusBox" style="display:none"></div>

      <div class="msg warn" id="after2Box" style="display:none">
        You’ve had two checks. What would you like to do?
        <div class="choiceRow">
          <button id="tryAgainBtn">Try again</button>
          <button id="showAnsBtn" class="primary">Show correct answer</button>
        </div>
      </div>

      <div style="height:10px"></div>
      <div class="btnrow">
        <button class="primary" id="checkBtn">Check</button>
      </div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div class="pill">Click / tap inside a region</div>
      <div class="pill">Scale: locked 1:1</div>
    </div>
    <div class="canvasWrap">
      <canvas id="cv"></canvas>
    </div>
  </section>
</div>

<script>
(() => {
  const MIN=-12, MAX=12, RANGE=MAX-MIN;

  // mask resolution: larger => fewer “leaks”
  const R_N = 720;

  // Always draw 6 boundaries (“six graphs”) for every mode/level.
  const SHAPES_TO_DRAW = 6;

  let mode=0, level=1;
  let ineqs=[], shapes=[];
  let regionId=null, regionCount=0, regionRep=[];
  let truthRegions=new Set();
  let selected=new Set();
  let failChecks=0;

  const cv=document.getElementById('cv');
  const ctx=cv.getContext('2d');

  const levelPill=document.getElementById('levelPill');
  const modeSel=document.getElementById('modeSel');
  const modeHelp=document.getElementById('modeHelp');
  const ineqList=document.getElementById('ineqList');
  const checkBtn=document.getElementById('checkBtn');
  const clearBtn=document.getElementById('clearBtn');
  const newBtn=document.getElementById('newBtn');
  const statusBox=document.getElementById('statusBox');
  const hintBox=document.getElementById('hintBox');

  const after2Box=document.getElementById('after2Box');
  const tryAgainBtn=document.getElementById('tryAgainBtn');
  const showAnsBtn=document.getElementById('showAnsBtn');

  const rnd=(a,b)=>a+Math.random()*(b-a);
  const pick=a=>a[(Math.random()*a.length)|0];
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const randSlope=()=>pick([-3,-2,-1.5,-1,-0.5,0.5,1,1.5,2,3]);

  function resizeCanvasToDisplaySize(){
    const dpr = window.devicePixelRatio || 1;
    const rect = cv.getBoundingClientRect();
    const w = Math.max(1, Math.round(rect.width * dpr));
    const h = Math.max(1, Math.round(rect.height * dpr));
    if (cv.width !== w || cv.height !== h){
      cv.width = w;
      cv.height = h;
    }
  }

  function niceNum(x){
    const r1=Math.round(x);
    if (Math.abs(x-r1)<1e-9) return String(r1);
    const r2=Math.round(x*2)/2;
    if (Math.abs(x-r2)<1e-9) return String(r2);
    const r10=Math.round(x*10)/10;
    if (Math.abs(x-r10)<1e-9) return String(r10);
    return String(Math.round(x*100)/100);
  }

  function showStatus(text, kind=""){
    statusBox.style.display="block";
    statusBox.className="msg"+(kind?(" "+kind):"");
    statusBox.textContent=text;
  }
  function showHint(t){hintBox.style.display="block"; hintBox.textContent=t;}
  function hideHint(){hintBox.style.display="none"; hintBox.textContent="";}
  function showAfter2(on){ after2Box.style.display = on ? "block" : "none"; }

  // --- 1:1 mapping always (square plot inside canvas) ---
  function plotSquare(){
    const w=cv.width,h=cv.height;
    const s=Math.min(w,h);
    return {s, ox:(w-s)/2, oy:(h-s)/2};
  }
  function worldToCanvas(x,y){
    const {s,ox,oy}=plotSquare();
    const sx=(x-MIN)/RANGE;
    const sy=(y-MIN)/RANGE;
    return {X:ox+sx*s, Y:oy+(1-sy)*s};
  }

  // --- Mask canvases ---
  const maskCv=document.createElement('canvas');
  maskCv.width=maskCv.height=R_N;
  const maskCtx=maskCv.getContext('2d', {willReadFrequently:true});
  maskCtx.imageSmoothingEnabled=false;

  const fillCv=document.createElement('canvas');
  fillCv.width=fillCv.height=R_N;
  const fillCtx=fillCv.getContext('2d', {willReadFrequently:true});
  fillCtx.imageSmoothingEnabled=false;

  // Thicker boundaries for mode 6 (rays/circles) to avoid leak-through.
  function boundaryThickness(){ return (mode===6) ? 10 : 4; }

  function worldToMask(x,y){
    const sx=(x-MIN)/RANGE;
    const sy=(y-MIN)/RANGE;
    const mx=Math.floor(clamp(sx,0,1)*(R_N-1));
    const my=Math.floor((1-clamp(sy,0,1))*(R_N-1));
    return {mx,my};
  }
  function maskToWorld(mx,my){
    const sx=mx/(R_N-1);
    const sy=1-my/(R_N-1);
    return {x:MIN+sx*RANGE, y:MIN+sy*RANGE};
  }

  // --- TeX helpers for mode 6 ---
  function texCoeffI(absIm){
    if (Math.abs(absIm-1)<1e-9) return `\\mathrm{i}`;
    return `${niceNum(absIm)}\\mathrm{i}`;
  }
  function texZMinusA_plain(re,im){
    const r=Math.round(re*2)/2;
    const i=Math.round(im*2)/2;
    let out="z";
    if (Math.abs(r)>1e-9){
      out += (r>0)?`-${niceNum(r)}`:`+${niceNum(-r)}`;
    }
    if (Math.abs(i)>1e-9){
      const term=texCoeffI(Math.abs(i));
      out += (i>0)?`-${term}`:`+${term}`;
    }
    return out;
  }
  function texPiFrac(kOverPi){
    const sign=kOverPi<0?"-":"";
    const a=Math.abs(kOverPi);
    let best={num:0,den:1,err:1e9};
    for(let den=1;den<=12;den++){
      const num=Math.round(a*den);
      const err=Math.abs(a-num/den);
      if(err<best.err) best={num,den,err};
    }
    const {num,den}=best;
    if(num===0) return "0";
    if(den===1){
      if(num===1) return `${sign}\\pi`;
      return `${sign}${num}\\pi`;
    }
    if(num===1) return `${sign}\\frac{\\pi}{${den}}`;
    return `${sign}\\frac{${num}\\pi}{${den}}`;
  }

  // --- Inequality factories ---
  function makeIneqVertical(a,dir){
    return { labelTex(){return `x ${dir} ${niceNum(a)}`;}, eval(x,y){return dir===">"?x>a+1e-9:x<a-1e-9;} };
  }
  function makeIneqHorizontal(b,dir){
    return { labelTex(){return `y ${dir} ${niceNum(b)}`;}, eval(x,y){return dir===">"?y>b+1e-9:y<b-1e-9;} };
  }
  function makeIneqLine(m,c,dir){
    return {
      labelTex(){
        const mStr=(Math.abs(m-1)<1e-9)?"":(Math.abs(m+1)<1e-9)?"-":niceNum(m);
        const xPart=(mStr==="")?"x":(mStr==="-")?"-x":`${mStr}x`;
        if(Math.abs(c)<1e-9) return `y ${dir} ${xPart}`;
        return `y ${dir} ${xPart} ${c>=0?"+":"-"} ${niceNum(Math.abs(c))}`;
      },
      eval(x,y){const rhs=m*x+c; return dir===">"?y>rhs+1e-9:y<rhs-1e-9;}
    };
  }
  function makeIneqParabola(a,h,k,dir){
    return {
      labelTex(){
        const aT = (Math.abs(a-1)<1e-9) ? "" : (Math.abs(a+1)<1e-9 ? "-" : niceNum(a));
        const hT = (Math.abs(h)<1e-9) ? "x" : `\\left(x ${h>=0?'-':'+'} ${niceNum(Math.abs(h))}\\right)`;
        const rhs = `${aT}${hT}^2 ${k>=0?'+':'-'} ${niceNum(Math.abs(k))}`;
        return `y ${dir} ${rhs}`;
      },
      eval(x,y){const rhs=a*(x-h)*(x-h)+k; return dir===">"?y>rhs+1e-9:y<rhs-1e-9;}
    };
  }
  function makeIneqCubic(a,b,c,d,dir){
    return {
      labelTex(){
        const parts=[];
        const add=(coef,tex)=>{
          if(Math.abs(coef)<1e-9) return;
          const s=coef>=0?"+":"-";
          const mag=Math.abs(coef);
          const coefTex=(Math.abs(mag-1)<1e-9)?"":niceNum(mag);
          parts.push({s,t:`${coefTex}${tex}`});
        };
        add(a,"x^3"); add(b,"x^2"); add(c,"x"); add(d,"");
        if(!parts.length) parts.push({s:"+",t:"0"});
        let out="";
        parts.forEach((p,i)=>{ out += (i===0 ? (p.s==="-"?"-":"")+p.t : ` ${p.s} ${p.t}`); });
        return `y ${dir} ${out}`;
      },
      eval(x,y){const rhs=a*x*x*x+b*x*x+c*x+d; return dir===">"?y>rhs+1e-9:y<rhs-1e-9;}
    };
  }
  function makeIneqSine(A,B,C,D,dir){
    return {
      labelTex(){ return `y ${dir} ${niceNum(A)} + ${niceNum(B)}\\sin\\!\\left(${niceNum(C)}x + ${niceNum(D)}\\right)`; },
      eval(x,y){const rhs=A+B*Math.sin(C*x+D); return dir===">"?y>rhs+1e-9:y<rhs-1e-9;}
    };
  }
  function makeIneqExp(A,B,base,C,dir){
    const isE=(base==="e");
    const baseTex=isE?"\\mathrm{e}":String(base);
    return {
      labelTex(){ return `y ${dir} ${niceNum(A)} + ${niceNum(B)}\\,${baseTex}^{${niceNum(C)}x}`; },
      eval(x,y){
        const pow=isE?Math.exp(C*x):Math.pow(Number(base),C*x);
        const rhs=A+B*pow;
        return dir===">"?y>rhs+1e-9:y<rhs-1e-9;
      }
    };
  }

  // Mode 6:
  function makeIneqCircle(cx,cy,r,dir){
    return {
      labelTex(){ return `\\left|${texZMinusA_plain(cx,cy)}\\right| ${dir} ${niceNum(r)}`; },
      eval(x,y){ const d=Math.hypot(x-cx,y-cy); return dir===">"?d>r+1e-9:d<r-1e-9; }
    };
  }
  function makeIneqArgBetween(cx,cy,lo,hi){
    return {
      labelTex(){ return `${texPiFrac(lo/Math.PI)} < \\arg\\!\\left(${texZMinusA_plain(cx,cy)}\\right) < ${texPiFrac(hi/Math.PI)}`; },
      eval(x,y){
        if(Math.hypot(x-cx,y-cy) < 1e-6) return false;
        const ang=Math.atan2(y-cy,x-cx);
        return ang>lo+1e-9 && ang<hi-1e-9;
      }
    };
  }
  function makeIneqBisector(ax,ay,bx,by,dir){
    return {
      labelTex(){ return `\\left|${texZMinusA_plain(ax,ay)}\\right| ${dir} \\left|${texZMinusA_plain(bx,by)}\\right|`; },
      eval(x,y){
        const da=Math.hypot(x-ax,y-ay);
        const db=Math.hypot(x-bx,y-by);
        return dir===">"?da>db+1e-9:da<db-1e-9;
      }
    };
  }

  // --- Shapes (boundaries only) ---
  function shapeLine(m,c){
    return {
      drawWorld(){
        const pts=[];
        for(const x of [MIN,MAX]){
          const y=m*x+c;
          if(y>=MIN-1e-9 && y<=MAX+1e-9) pts.push({x,y});
        }
        if(Math.abs(m)>1e-12){
          for(const y of [MIN,MAX]){
            const x=(y-c)/m;
            if(x>=MIN-1e-9 && x<=MAX+1e-9) pts.push({x,y});
          }
        }
        if(pts.length<2) return;
        const A=pts[0], B=pts[1];
        const pA=worldToCanvas(A.x,A.y), pB=worldToCanvas(B.x,B.y);
        ctx.beginPath(); ctx.moveTo(pA.X,pA.Y); ctx.lineTo(pB.X,pB.Y); ctx.stroke();
      },
      drawMask(){
        const pts=[];
        for(const x of [MIN,MAX]){
          const y=m*x+c;
          if(y>=MIN-1e-9 && y<=MAX+1e-9) pts.push({x,y});
        }
        if(Math.abs(m)>1e-12){
          for(const y of [MIN,MAX]){
            const x=(y-c)/m;
            if(x>=MIN-1e-9 && x<=MAX+1e-9) pts.push({x,y});
          }
        }
        if(pts.length<2) return;
        const A=pts[0], B=pts[1];
        const pA=worldToMask(A.x,A.y), pB=worldToMask(B.x,B.y);
        maskCtx.beginPath();
        maskCtx.moveTo(pA.mx+0.5,pA.my+0.5);
        maskCtx.lineTo(pB.mx+0.5,pB.my+0.5);
        maskCtx.stroke();
      }
    };
  }
  function shapeVertical(a){
    return {
      drawWorld(){
        const p1=worldToCanvas(a,MIN), p2=worldToCanvas(a,MAX);
        ctx.beginPath(); ctx.moveTo(p1.X,p1.Y); ctx.lineTo(p2.X,p2.Y); ctx.stroke();
      },
      drawMask(){
        const p1=worldToMask(a,MIN), p2=worldToMask(a,MAX);
        maskCtx.beginPath();
        maskCtx.moveTo(p1.mx+0.5,p1.my+0.5);
        maskCtx.lineTo(p2.mx+0.5,p2.my+0.5);
        maskCtx.stroke();
      }
    };
  }
  function shapeHorizontal(b){
    return {
      drawWorld(){
        const p1=worldToCanvas(MIN,b), p2=worldToCanvas(MAX,b);
        ctx.beginPath(); ctx.moveTo(p1.X,p1.Y); ctx.lineTo(p2.X,p2.Y); ctx.stroke();
      },
      drawMask(){
        const p1=worldToMask(MIN,b), p2=worldToMask(MAX,b);
        maskCtx.beginPath();
        maskCtx.moveTo(p1.mx+0.5,p1.my+0.5);
        maskCtx.lineTo(p2.mx+0.5,p2.my+0.5);
        maskCtx.stroke();
      }
    };
  }
  function shapeGraph(fn){
    return {
      drawWorld(){
        const steps=1200;
        let started=false;
        for(let i=0;i<=steps;i++){
          const x=MIN+RANGE*(i/steps);
          const y=fn(x);
          if(!Number.isFinite(y)){ started=false; continue; }
          const p=worldToCanvas(x,y);
          if(!started){ ctx.beginPath(); ctx.moveTo(p.X,p.Y); started=true; }
          else ctx.lineTo(p.X,p.Y);
        }
        if(started) ctx.stroke();
      },
      drawMask(){
        const steps=1200;
        let started=false;
        for(let i=0;i<=steps;i++){
          const x=MIN+RANGE*(i/steps);
          const y=fn(x);
          if(!Number.isFinite(y)){ started=false; continue; }
          const p=worldToMask(x,y);
          if(!started){ maskCtx.beginPath(); maskCtx.moveTo(p.mx+0.5,p.my+0.5); started=true; }
          else maskCtx.lineTo(p.mx+0.5,p.my+0.5);
        }
        if(started) maskCtx.stroke();
      }
    };
  }
  function shapeCircle(cx,cy,r){
    return {
      drawWorld(){
        const steps=900;
        ctx.beginPath();
        for(let i=0;i<=steps;i++){
          const t=i/steps*2*Math.PI;
          const x=cx+r*Math.cos(t), y=cy+r*Math.sin(t);
          const p=worldToCanvas(x,y);
          if(i===0) ctx.moveTo(p.X,p.Y); else ctx.lineTo(p.X,p.Y);
        }
        ctx.stroke();
      },
      drawMask(){
        const steps=900;
        maskCtx.beginPath();
        for(let i=0;i<=steps;i++){
          const t=i/steps*2*Math.PI;
          const x=cx+r*Math.cos(t), y=cy+r*Math.sin(t);
          const p=worldToMask(x,y);
          if(i===0) maskCtx.moveTo(p.mx+0.5,p.my+0.5); else maskCtx.lineTo(p.mx+0.5,p.my+0.5);
        }
        maskCtx.stroke();
      }
    };
  }

  // robust ray: extend until it hits the bounding square so the boundary is guaranteed to connect.
  function shapeRay(cx,cy,theta){
    function rayEndpoint(){
      const dx=Math.cos(theta), dy=Math.sin(theta);
      let bestT = Infinity;

      if(Math.abs(dx)>1e-12){
        const t1=(MIN-cx)/dx, t2=(MAX-cx)/dx;
        if(t1>0) bestT=Math.min(bestT,t1);
        if(t2>0) bestT=Math.min(bestT,t2);
      }
      if(Math.abs(dy)>1e-12){
        const t3=(MIN-cy)/dy, t4=(MAX-cy)/dy;
        if(t3>0) bestT=Math.min(bestT,t3);
        if(t4>0) bestT=Math.min(bestT,t4);
      }
      if(!Number.isFinite(bestT) || bestT===Infinity) bestT=30;
      const pad = 0.25;
      return {x:cx+(bestT+pad)*dx, y:cy+(bestT+pad)*dy};
    }
    return {
      drawWorld(){
        const p0=worldToCanvas(cx,cy);
        const end=rayEndpoint();
        const p1=worldToCanvas(end.x,end.y);
        ctx.beginPath(); ctx.moveTo(p0.X,p0.Y); ctx.lineTo(p1.X,p1.Y); ctx.stroke();
        if(mode===6){
          ctx.save();
          ctx.fillStyle="rgba(17,24,39,0.75)";
          ctx.beginPath();
          ctx.arc(p0.X,p0.Y,3.2,0,Math.PI*2);
          ctx.fill();
          ctx.restore();
        }
      },
      drawMask(){
        const p0=worldToMask(cx,cy);
        const end=rayEndpoint();
        const p1=worldToMask(end.x,end.y);

        maskCtx.save();
        maskCtx.lineCap="butt";
        maskCtx.lineJoin="miter";
        maskCtx.beginPath();
        maskCtx.moveTo(p0.mx+0.5,p0.my+0.5);
        maskCtx.lineTo(p1.mx+0.5,p1.my+0.5);
        maskCtx.stroke();

        const r = Math.max(6, Math.ceil(maskCtx.lineWidth*0.8));
        maskCtx.fillStyle="#000";
        maskCtx.beginPath();
        maskCtx.arc(p0.mx+0.5,p0.my+0.5,r,0,Math.PI*2);
        maskCtx.fill();
        maskCtx.restore();
      }
    };
  }

  // --- Mask sealing (fixes Mode 6 “shading over line”) ---
  function sealMaskBoundaries(){
    const img = maskCtx.getImageData(0,0,R_N,R_N);
    const d = img.data;

    const isDark = (i) => (d[i]+d[i+1]+d[i+2]) < 180;
    const B = new Uint8Array(R_N*R_N);

    for(let y=0;y<R_N;y++){
      for(let x=0;x<R_N;x++){
        const i = 4*(y*R_N+x);
        if(isDark(i)) B[y*R_N+x]=1;
      }
    }

    const rad = (mode===6) ? 2 : 1;
    const out = new Uint8Array(R_N*R_N);

    for(let y=0;y<R_N;y++){
      for(let x=0;x<R_N;x++){
        let v = 0;
        for(let dy=-rad; dy<=rad && !v; dy++){
          const yy=y+dy; if(yy<0||yy>=R_N) continue;
          for(let dx=-rad; dx<=rad; dx++){
            const xx=x+dx; if(xx<0||xx>=R_N) continue;
            if(B[yy*R_N+xx]) { v=1; break; }
          }
        }
        out[y*R_N+x]=v;
      }
    }

    for(let y=0;y<R_N;y++){
      for(let x=0;x<R_N;x++){
        const i=4*(y*R_N+x);
        if(out[y*R_N+x]){
          d[i]=0; d[i+1]=0; d[i+2]=0; d[i+3]=255;
        }else{
          d[i]=255; d[i+1]=255; d[i+2]=255; d[i+3]=255;
        }
      }
    }
    maskCtx.putImageData(img,0,0);
  }

  // --- Mask to regions ---
  function drawMaskBoundaries(){
    maskCtx.fillStyle="#fff";
    maskCtx.fillRect(0,0,R_N,R_N);

    maskCtx.strokeStyle="#000";
    maskCtx.lineWidth=boundaryThickness();
    maskCtx.lineCap="butt";
    maskCtx.lineJoin="miter";

    maskCtx.strokeRect(0.5,0.5,R_N-1,R_N-1);

    for(const s of shapes) s.drawMask();

    sealMaskBoundaries();
  }

  function buildRegionsFromMask(){
    const img=maskCtx.getImageData(0,0,R_N,R_N).data;
    regionId=new Int32Array(R_N*R_N);
    regionRep=[];
    regionCount=0;

    const isBoundary = (p) => (img[p]+img[p+1]+img[p+2]) < 60;

    const qx=new Int32Array(R_N*R_N);
    const qy=new Int32Array(R_N*R_N);

    const idxPix=(x,y)=>4*(y*R_N+x);
    const idxCell=(x,y)=>y*R_N+x;

    for(let y=0;y<R_N;y++){
      for(let x=0;x<R_N;x++){
        const cell=idxCell(x,y);
        if(regionId[cell]!==0) continue;
        if(isBoundary(idxPix(x,y))) continue;

        regionCount++;
        const rid=regionCount;
        let head=0, tail=0;
        qx[tail]=x; qy[tail]=y; tail++;
        regionId[cell]=rid;
        regionRep[rid]={mx:x,my:y};

        while(head<tail){
          const cx=qx[head], cy=qy[head]; head++;
          const neigh=[[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]];
          for(const [nx,ny] of neigh){
            if(nx<0||nx>=R_N||ny<0||ny>=R_N) continue;
            const ccell=idxCell(nx,ny);
            if(regionId[ccell]!==0) continue;
            if(isBoundary(idxPix(nx,ny))) continue;
            regionId[ccell]=rid;
            qx[tail]=nx; qy[tail]=ny; tail++;
          }
        }
      }
    }
  }

  function computeTruthRegions(){
    truthRegions=new Set();
    for(let rid=1; rid<=regionCount; rid++){
      const rep=regionRep[rid];
      if(!rep) continue;
      const {x,y}=maskToWorld(rep.mx,rep.my);
      let ok=true;
      for(const inq of ineqs){
        if(!inq.eval(x,y)){ ok=false; break; }
      }
      if(ok) truthRegions.add(rid);
    }
  }

  function rebuildFillOverlay(){
    const img=fillCtx.createImageData(R_N,R_N);
    const d=img.data;
    for(let y=0;y<R_N;y++){
      for(let x=0;x<R_N;x++){
        const rid=regionId[y*R_N+x];
        if(rid>0 && selected.has(rid)){
          const k=4*(y*R_N+x);
          d[k]=249; d[k+1]=115; d[k+2]=22; d[k+3]=70;
        }
      }
    }
    fillCtx.putImageData(img,0,0);
  }

  // --- drawing ---
  function drawAxes(){
    const {s,ox,oy}=plotSquare();
    ctx.lineWidth=2.0;
    ctx.strokeStyle="rgba(17,24,39,0.35)";
    ctx.strokeRect(ox,oy,s,s);

    const p0=worldToCanvas(0,0);
    ctx.strokeStyle="rgba(17,24,39,0.35)";
    ctx.lineWidth=2.1;
    ctx.beginPath(); ctx.moveTo(p0.X,oy); ctx.lineTo(p0.X,oy+s); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ox,p0.Y); ctx.lineTo(ox+s,p0.Y); ctx.stroke();

    ctx.fillStyle="rgba(17,24,39,0.70)";
    ctx.font="14px system-ui,-apple-system,Segoe UI,Roboto,Arial";
    ctx.textAlign="center"; ctx.textBaseline="top";
    for(let x=-12;x<=12;x+=2){
      const p=worldToCanvas(x,0);
      if(p.X<ox-2||p.X>ox+s+2) continue;
      ctx.strokeStyle="rgba(17,24,39,0.25)";
      ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.moveTo(p.X,p0.Y-6); ctx.lineTo(p.X,p0.Y+6); ctx.stroke();
      if(x!==0) ctx.fillText(String(x),p.X,p0.Y+10);
    }
    ctx.textAlign="right"; ctx.textBaseline="middle";
    for(let y=-12;y<=12;y+=2){
      const p=worldToCanvas(0,y);
      if(p.Y<oy-2||p.Y>oy+s+2) continue;
      ctx.strokeStyle="rgba(17,24,39,0.25)";
      ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.moveTo(p0.X-6,p.Y); ctx.lineTo(p0.X+6,p.Y); ctx.stroke();
      if(y!==0) ctx.fillText(String(y),p0.X-10,p.Y);
    }
  }

  function drawAll(){
    resizeCanvasToDisplaySize();

    ctx.clearRect(0,0,cv.width,cv.height);
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,cv.width,cv.height);

    const {s,ox,oy}=plotSquare();
    ctx.imageSmoothingEnabled=false;
    ctx.drawImage(fillCv, 0,0,R_N,R_N, ox,oy,s,s);
    ctx.imageSmoothingEnabled=true;

    ctx.strokeStyle="rgba(17,24,39,0.55)";
    ctx.lineWidth=2.8;
    for(const s2 of shapes) s2.drawWorld();

    drawAxes();
  }

  // --- render inequalities ---
  function renderIneqList(){
    levelPill.textContent = `Level ${level} / 6`;
    ineqList.innerHTML="";
    ineqs.forEach((inq,i)=>{
      const d=document.createElement("div");
      d.className="ineq";
      d.innerHTML=`<div class="k">Inequality ${i+1}</div><div class="v">\\(${inq.labelTex()}\\)</div>`;
      ineqList.appendChild(d);
    });
    if(window.MathJax?.typesetPromise){
      MathJax.typesetClear?.([ineqList]);
      MathJax.typesetPromise([ineqList]).catch(()=>{});
    }
  }

  function modeDescription(m){
    return [
      "Mode 0: only x=a and y=b (still shows 6 boundaries).",
      "Mode 1: Lines — 6 line graphs shown; Level n gives n inequalities.",
      "Mode 2: lines + parabolas (6 boundaries total).",
      "Mode 3: lines + parabolas + cubics (6 boundaries total).",
      "Mode 4: lines + sine waves (6 boundaries total).",
      "Mode 5: lines + exponentials (6 boundaries total; e upright).",
      "Mode 6: complex loci (upright i; arg-between uses rays)."
    ][m] || "";
  }

  // --- Utility: pick k distinct items from a list ---
  function pickKDistinct(arr,k){
    const idx=arr.map((_,i)=>i);
    for(let i=idx.length-1;i>0;i--){
      const j=(Math.random()*(i+1))|0;
      [idx[i],idx[j]]=[idx[j],idx[i]];
    }
    return idx.slice(0,k).map(i=>arr[i]);
  }

  // --- Generators: ALWAYS 6 shapes shown; choose k inequalities from them ---
  function generateMode0(k){
    const items=[];
    for(let i=0;i<SHAPES_TO_DRAW;i++){
      if(Math.random()<0.5){
        const a=Math.round(rnd(-9,9)*2)/2;
        items.push({shape: shapeVertical(a), inq: ()=>makeIneqVertical(a, Math.random()<0.5?">":"<")});
      }else{
        const b=Math.round(rnd(-9,9)*2)/2;
        items.push({shape: shapeHorizontal(b), inq: ()=>makeIneqHorizontal(b, Math.random()<0.5?">":"<")});
      }
    }
    shapes = items.map(it=>it.shape);
    ineqs = pickKDistinct(items,k).map(it=>it.inq());
  }

  function generateMode1(k){
    const items=[];
    const used=[];
    const tooClose=(m,c)=>used.some(L=>Math.abs(L.m-m)<0.35 && Math.abs(L.c-c)<1.2);
    while(items.length<SHAPES_TO_DRAW){
      const m=randSlope();
      const c=Math.round(rnd(-8,8)*2)/2;
      if(tooClose(m,c)) continue;
      used.push({m,c});
      items.push({shape: shapeLine(m,c), inq: ()=>makeIneqLine(m,c, Math.random()<0.5?">":"<")});
    }
    shapes = items.map(it=>it.shape);
    ineqs = pickKDistinct(items,k).map(it=>it.inq());
  }

  function generateMode2(k){
    const items=[];
    for(let i=0;i<3;i++){
      const m=randSlope();
      const c=Math.round(rnd(-8,8)*2)/2;
      items.push({shape: shapeLine(m,c), inq: ()=>makeIneqLine(m,c, Math.random()<0.5?">":"<")});
    }
    for(let i=0;i<3;i++){
      const a=pick([-1,-0.5,0.5,1]);
      const h=Math.round(rnd(-6,6)*2)/2;
      const kk=Math.round(rnd(-6,6)*2)/2;
      const fn=(x)=>a*(x-h)*(x-h)+kk;
      items.push({shape: shapeGraph(fn), inq: ()=>makeIneqParabola(a,h,kk, Math.random()<0.5?">":"<")});
    }
    shapes = items.map(it=>it.shape);
    ineqs = pickKDistinct(items,k).map(it=>it.inq());
  }

  function generateMode3(k){
    const items=[];
    for(let i=0;i<2;i++){
      const m=randSlope();
      const c=Math.round(rnd(-8,8)*2)/2;
      items.push({shape: shapeLine(m,c), inq: ()=>makeIneqLine(m,c, Math.random()<0.5?">":"<")});
    }
    for(let i=0;i<2;i++){
      const a=pick([-1,-0.5,0.5,1]);
      const h=Math.round(rnd(-6,6)*2)/2;
      const kk=Math.round(rnd(-6,6)*2)/2;
      const fn=(x)=>a*(x-h)*(x-h)+kk;
      items.push({shape: shapeGraph(fn), inq: ()=>makeIneqParabola(a,h,kk, Math.random()<0.5?">":"<")});
    }
    for(let i=0;i<2;i++){
      const a=pick([-0.2,-0.15,0.15,0.2]);
      const b=Math.round(rnd(-0.5,0.5)*10)/10;
      const c=Math.round(rnd(-2.5,2.5)*2)/2;
      const d=Math.round(rnd(-5,5)*2)/2;
      const fn=(x)=>a*x*x*x+b*x*x+c*x+d;
      items.push({shape: shapeGraph(fn), inq: ()=>makeIneqCubic(a,b,c,d, Math.random()<0.5?">":"<")});
    }
    shapes = items.map(it=>it.shape);
    ineqs = pickKDistinct(items,k).map(it=>it.inq());
  }

  function generateMode4(k){
    const items=[];
    for(let i=0;i<3;i++){
      const m=randSlope();
      const c=Math.round(rnd(-8,8)*2)/2;
      items.push({shape: shapeLine(m,c), inq: ()=>makeIneqLine(m,c, Math.random()<0.5?">":"<")});
    }
    for(let i=0;i<3;i++){
      const A=Math.round(rnd(-4,4)*2)/2;
      const B=pick([1,1.5,2,2.5,3]);
      const C=pick([0.5,0.75,1,1.25]);
      const D=Math.round(rnd(-Math.PI,Math.PI)*4)/4;
      const fn=(x)=>A+B*Math.sin(C*x+D);
      items.push({shape: shapeGraph(fn), inq: ()=>makeIneqSine(A,B,C,D, Math.random()<0.5?">":"<")});
    }
    shapes = items.map(it=>it.shape);
    ineqs = pickKDistinct(items,k).map(it=>it.inq());
  }

  function generateMode5(k){
    const items=[];
    for(let i=0;i<3;i++){
      const m=randSlope();
      const c=Math.round(rnd(-8,8)*2)/2;
      items.push({shape: shapeLine(m,c), inq: ()=>makeIneqLine(m,c, Math.random()<0.5?">":"<")});
    }
    for(let i=0;i<3;i++){
      const A=Math.round(rnd(-4,4)*2)/2;
      const B=pick([-2,-1.5,-1,1,1.5,2]);
      const base=pick(["e",2,3]);
      const C=pick([0.25,0.3,0.4,0.5]);
      const isE=(base==="e");
      const fn=(x)=>A + B*(isE?Math.exp(C*x):Math.pow(base,C*x));
      items.push({shape: shapeGraph(fn), inq: ()=>makeIneqExp(A,B,base,C, Math.random()<0.5?">":"<")});
    }
    shapes = items.map(it=>it.shape);
    ineqs = pickKDistinct(items,k).map(it=>it.inq());
  }

  function generateMode6(k){
    // 2 circles + 2 bisectors + 2 rays (wedge) = 6 boundaries total
    const items=[];

    const c1x=Math.round(rnd(-6,6)*2)/2;
    const c1y=Math.round(rnd(-6,6)*2)/2;
    const r1=pick([2,2.5,3,3.5,4]);
    items.push({ shape: shapeCircle(c1x,c1y,r1), inq: ()=>makeIneqCircle(c1x,c1y,r1, Math.random()<0.5?"<":">") });

    const c2x=Math.round(rnd(-6,6)*2)/2;
    const c2y=Math.round(rnd(-6,6)*2)/2;
    const r2=pick([2,2.5,3,3.5,4]);
    items.push({ shape: shapeCircle(c2x,c2y,r2), inq: ()=>makeIneqCircle(c2x,c2y,r2, Math.random()<0.5?"<":">") });

    // bisector 1
    const a1x=Math.round(rnd(-7,7)), a1y=Math.round(rnd(-7,7));
    const b1x=Math.round(rnd(-7,7)), b1y=Math.round(rnd(-7,7));
    const mx1=(a1x+b1x)/2, my1=(a1y+b1y)/2;
    const dx1=b1x-a1x, dy1=b1y-a1y;
    const vx1=-dy1, vy1=dx1;
    if(Math.abs(vx1)<1e-9){
      items.push({ shape: shapeVertical(mx1), inq: ()=>makeIneqBisector(a1x,a1y,b1x,b1y, Math.random()<0.5?"<":">")});
    }else{
      const m1=vy1/vx1;
      const c1=my1-m1*mx1;
      items.push({ shape: shapeLine(m1,c1), inq: ()=>makeIneqBisector(a1x,a1y,b1x,b1y, Math.random()<0.5?"<":">")});
    }

    // bisector 2
    const a2x=Math.round(rnd(-7,7)), a2y=Math.round(rnd(-7,7));
    const b2x=Math.round(rnd(-7,7)), b2y=Math.round(rnd(-7,7));
    const mx2=(a2x+b2x)/2, my2=(a2y+b2y)/2;
    const dx2=b2x-a2x, dy2=b2y-a2y;
    const vx2=-dy2, vy2=dx2;
    if(Math.abs(vx2)<1e-9){
      items.push({ shape: shapeVertical(mx2), inq: ()=>makeIneqBisector(a2x,a2y,b2x,b2y, Math.random()<0.5?"<":">")});
    }else{
      const m2=vy2/vx2;
      const c2=my2-m2*mx2;
      items.push({ shape: shapeLine(m2,c2), inq: ()=>makeIneqBisector(a2x,a2y,b2x,b2y, Math.random()<0.5?"<":">")});
    }

    // arg-between wedge (two rays are boundaries; ONE inequality)
    const cx=Math.round(rnd(-5,5)*2)/2;
    const cy=Math.round(rnd(-5,5)*2)/2;
    const angs=[];
    for(let t=-Math.PI; t<=Math.PI+1e-9; t+=Math.PI/12) angs.push(Math.round(t*1e6)/1e6);
    let lo=pick(angs), hi=pick(angs);
    if(lo>hi){ const tmp=lo; lo=hi; hi=tmp; }
    if(hi-lo < Math.PI/6){ hi = lo + Math.PI/3; }
    hi = clamp(hi, -Math.PI, Math.PI);
    lo = clamp(lo, -Math.PI, Math.PI);

    const ray1 = shapeRay(cx,cy,lo);
    const ray2 = shapeRay(cx,cy,hi);

    // Keep BOTH rays as shapes so we still show 6 boundaries,
    // but for inequality selection, treat wedge as one choice.
    items.push({ shape: ray1, inq: ()=>makeIneqArgBetween(cx,cy,lo,hi), tag:"wedge" });
    items.push({ shape: ray2, inq: ()=>makeIneqArgBetween(cx,cy,lo,hi), tag:"wedge" });

    shapes = items.map(it=>it.shape);

    // Build selectable inequality pool (unique wedge)
    const pool = [
      {fn: items[0].inq, tag:"c1"},
      {fn: items[1].inq, tag:"c2"},
      {fn: items[2].inq, tag:"b1"},
      {fn: items[3].inq, tag:"b2"},
      {fn: items[4].inq, tag:"wedge"} // include wedge once
    ];

    // If k=6, add one extra from the non-wedge set
    while(pool.length < Math.min(k,6)){
      pool.push(pick([{fn:items[0].inq,tag:"c1x"},{fn:items[1].inq,tag:"c2x"},{fn:items[2].inq,tag:"b1x"},{fn:items[3].inq,tag:"b2x"}]));
    }

    const chosen = pickKDistinct(pool, k).map(o=>o.fn());
    ineqs = chosen;
  }

  function generateAll(){
    failChecks=0;
    showAfter2(false);
    hideHint();
    statusBox.style.display="none";

    const k=level;
    modeHelp.textContent = modeDescription(mode);

    if(mode===0) generateMode0(k);
    else if(mode===1) generateMode1(k);
    else if(mode===2) generateMode2(k);
    else if(mode===3) generateMode3(k);
    else if(mode===4) generateMode4(k);
    else if(mode===5) generateMode5(k);
    else generateMode6(k);

    renderIneqList();

    selected = new Set();          // ok

    drawMaskBoundaries();
    buildRegionsFromMask();
    computeTruthRegions();

    rebuildFillOverlay();          // now regionId exists
    drawAll();
  }

  // --- Interaction ---
  function regionAtCanvasPoint(clientX, clientY){
    const rect=cv.getBoundingClientRect();
    const dpr=window.devicePixelRatio||1;
    const X=(clientX-rect.left)*dpr;
    const Y=(clientY-rect.top)*dpr;

    const {s,ox,oy}=plotSquare();
    if(X<ox || X>ox+s || Y<oy || Y>oy+s) return null;

    const nx=(X-ox)/s;
    const ny=(Y-oy)/s;
    const mx=Math.floor(clamp(nx,0,1)*(R_N-1));
    const my=Math.floor(clamp(ny,0,1)*(R_N-1));
    if(!regionId) return null;
    const rid=regionId[my*R_N+mx];
    return rid>0?rid:null;
  }

  function toggleRegion(rid){
    if(selected.has(rid)) selected.delete(rid);
    else selected.add(rid);
    rebuildFillOverlay();
    drawAll();
  }

  cv.addEventListener("pointerdown", (e)=>{
    const rid=regionAtCanvasPoint(e.clientX,e.clientY);
    if(rid==null) return;
    toggleRegion(rid);
  });

  function clearShading(){
    selected=new Set();
    rebuildFillOverlay();
    drawAll();
    showStatus("Shading cleared.","");
  }

  function setsEqual(a,b){
    if(a.size!==b.size) return false;
    for(const v of a) if(!b.has(v)) return false;
    return true;
  }

  function showCorrectAnswer(){
    selected = new Set(truthRegions);
    rebuildFillOverlay();
    drawAll();
    showStatus("Correct regions shown.","good");
  }

  function doCheck(){
    if(!truthRegions || !regionId){
      showStatus("Something didn’t initialise. Click “New image”.","bad");
      return;
    }
    if(setsEqual(selected, truthRegions)){
      showStatus("Correct ✅","good");
      showAfter2(false);
      failChecks=0;
      level = (level % 6) + 1;
      generateAll();
      return;
    }

    failChecks++;
    showStatus("Not quite — adjust your shading and try again.","bad");
    if(failChecks===1){
      showHint("Tip: The correct region(s) are the intersection of all inequalities. Rays/circles in Mode 6 are sealed to prevent leakage.");
    }
    if(failChecks>=2){
      showAfter2(true);
    }
  }

  // --- Buttons / UI ---
  clearBtn.addEventListener("click", clearShading);
  newBtn.addEventListener("click", generateAll);
  checkBtn.addEventListener("click", doCheck);

  tryAgainBtn.addEventListener("click", ()=>{
    showAfter2(false);
    showStatus("Try again.","");
  });
  showAnsBtn.addEventListener("click", ()=>{
    showAfter2(false);
    showCorrectAnswer();
  });

  modeSel.addEventListener("change", ()=>{
    mode = Number(modeSel.value)||0;
    level = 1;
    generateAll();
  });

  window.addEventListener("resize", ()=>{ drawAll(); });

  generateAll();
})();
</script>
</body>
</html>
