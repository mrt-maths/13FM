<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Region Shading (Modes 0–6)</title>

<script>
  window.MathJax = {
    tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
    options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

<style>
  :root{
    --bg:#f5f7fb; --card:#fff; --ink:#111827; --muted:#6b7280; --line:#e5e7eb;
    --accent:#f97316; --good:#16a34a; --bad:#dc2626; --warn:#d97706;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--ink)}
  header{padding:14px 16px}
  header h1{margin:0;font-size:18px}
  header p{margin:6px 0 0;color:var(--muted);font-size:13px}

  .wrap{display:grid;grid-template-columns:420px 1fr;gap:14px;padding:0 16px 16px}
  @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }

  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;box-shadow:0 8px 18px rgba(0,0,0,.05)}
  .card .hd{padding:12px 14px;border-bottom:1px solid var(--line);display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  .card .bd{padding:12px 14px}

  .btnrow{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  button{
    appearance:none;border:1px solid var(--line);background:#fff;color:var(--ink);
    padding:10px 12px;border-radius:12px;font-weight:650;cursor:pointer;
    transition:.12s; user-select:none;
  }
  button:hover{transform:translateY(-1px);box-shadow:0 10px 16px rgba(0,0,0,.06)}
  button:disabled{opacity:.55;cursor:not-allowed;transform:none;box-shadow:none}
  .primary{background:var(--accent);border-color:transparent;color:#fff}
  .pill{font-size:12px;color:var(--muted);border:1px solid var(--line);padding:6px 10px;border-radius:999px;white-space:nowrap}
  select{
    border:1px solid var(--line); border-radius:12px; padding:10px 12px;
    font-weight:650; background:#fff; color:var(--ink);
  }

  .list{display:flex;flex-direction:column;gap:10px;margin-top:10px}
  .ineq{border:1px solid var(--line);border-radius:12px;padding:10px;background:#fff}
  .ineq .k{font-size:12px;color:var(--muted);margin-bottom:6px}
  .ineq .v{font-size:18px;font-weight:850}
  .ineq .v mjx-container{ font-size: 110% !important; }

  .small{font-size:12px;color:var(--muted)}
  .msg{margin-top:10px;padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:#fafafa}
  .msg.good{border-color:rgba(22,163,74,.35);background:rgba(22,163,74,.08);color:#0f5132}
  .msg.bad{border-color:rgba(220,38,38,.35);background:rgba(220,38,38,.08);color:#7f1d1d}
  .msg.warn{border-color:rgba(217,119,6,.35);background:rgba(217,119,6,.10);color:#7c2d12}

  .canvasWrap{padding:12px}
  canvas{width:100%;height:560px;display:block;border-radius:14px;border:1px solid var(--line);background:#fff;touch-action:none}
  @media (max-width: 980px){ canvas{height:520px} }

  .choiceRow{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
</style>
</head>
<body>
<header>
  <h1>Region Shading — Multiple Modes</h1>
  <p>Click inside a region to fill/unfill it (screen edge is a boundary). Select all regions where <b>all</b> inequalities are true, then press <b>Check</b>. (Zoom disabled; always −12 to 12.)</p>
</header>

<div class="wrap">
  <section class="card">
    <div class="hd">
      <div class="btnrow">
        <span class="pill" id="levelPill">Level 1 / 6</span>
        <label class="pill" style="display:flex;gap:8px;align-items:center">
          Mode
          <select id="modeSel" aria-label="Mode">
            <option value="0">Mode 0: x=a and y=b only</option>
            <option value="1">Mode 1: 6 lines (some are red herrings)</option>
            <option value="2">Mode 2: lines + parabolas</option>
            <option value="3">Mode 3: lines + parabolas + cubics</option>
            <option value="4">Mode 4: lines + sine waves</option>
            <option value="5">Mode 5: lines + exponentials</option>
            <option value="6">Mode 6: complex loci</option>
          </select>
        </label>
      </div>
      <div class="btnrow">
        <button id="clearBtn">Clear shading</button>
        <button id="newBtn">New image</button>
      </div>
    </div>

    <div class="bd">
      <div class="small" id="modeHelp"></div>
      <div class="list" id="ineqList"></div>

      <div class="msg warn" id="hintBox" style="display:none"></div>
      <div class="msg" id="statusBox" style="display:none"></div>

      <div class="msg warn" id="after2Box" style="display:none">
        You’ve had two checks. What would you like to do?
        <div class="choiceRow">
          <button id="tryAgainBtn">Try again</button>
          <button id="showAnsBtn" class="primary">Show correct answer</button>
        </div>
      </div>

      <div style="height:10px"></div>
      <div class="btnrow">
        <button class="primary" id="checkBtn">Check</button>
        <span class="pill" id="timerPill" style="display:none">Check available in 60s</span>
      </div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div class="pill">Click / tap inside a region</div>
      <div class="pill">Scale: locked 1:1</div>
    </div>
    <div class="canvasWrap">
      <canvas id="cv" width="1200" height="800"></canvas>
    </div>
  </section>
</div>

<script>
(() => {
  const MIN=-12, MAX=12, RANGE=MAX-MIN;

  const DISABLE_MS = 60_000;
  const R_N = 720;                 // higher -> less angular “wobble” for arg rays
  const MAX_REGIONS_ALLOWED = 18;  // mode 1 has 6 lines, allow more regions

  let mode=0, level=1;
  let ineqs=[], shapes=[];
  let regionId=null, regionCount=0, regionRep=[];
  let truthRegions=new Set();
  let selected=new Set();
  let disableTimer=null;
  let failChecks=0;

  const cv=document.getElementById('cv');
  const ctx=cv?.getContext('2d');
  const levelPill=document.getElementById('levelPill');
  const modeSel=document.getElementById('modeSel');
  const modeHelp=document.getElementById('modeHelp');
  const ineqList=document.getElementById('ineqList');
  const checkBtn=document.getElementById('checkBtn');
  const clearBtn=document.getElementById('clearBtn');
  const newBtn=document.getElementById('newBtn');
  const statusBox=document.getElementById('statusBox');
  const hintBox=document.getElementById('hintBox');
  const timerPill=document.getElementById('timerPill');

  const after2Box=document.getElementById('after2Box');
  const tryAgainBtn=document.getElementById('tryAgainBtn');
  const showAnsBtn=document.getElementById('showAnsBtn');

  const rnd=(a,b)=>a+Math.random()*(b-a);
  const pick=a=>a[(Math.random()*a.length)|0];
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const randSlope=()=>pick([-3,-2,-1.5,-1,-0.5,0.5,1,1.5,2,3]);

  function niceNum(x){
    const r1=Math.round(x);
    if (Math.abs(x-r1)<1e-9) return String(r1);
    const r2=Math.round(x*2)/2;
    if (Math.abs(x-r2)<1e-9) return String(r2);
    const r10=Math.round(x*10)/10;
    if (Math.abs(x-r10)<1e-9) return String(r10);
    return String(Math.round(x*100)/100);
  }

  function showStatus(text, kind=""){
    statusBox.style.display="block";
    statusBox.className="msg"+(kind?(" "+kind):"");
    statusBox.textContent=text;
  }
  function showHint(t){hintBox.style.display="block"; hintBox.textContent=t;}
  function hideHint(){hintBox.style.display="none"; hintBox.textContent="";}
  function showAfter2(on){ after2Box.style.display = on ? "block" : "none"; }

  function enableCheck(on){
    checkBtn.disabled=!on;
    timerPill.style.display = on ? "none" : "inline-flex";
  }
  function clearCooldown(){
    if (disableTimer){ clearInterval(disableTimer); disableTimer=null; }
    enableCheck(true);
    timerPill.textContent="Check available";
  }
  function startDisableCountdown(){
    const start=Date.now();
    enableCheck(false);
    if (disableTimer) clearInterval(disableTimer);
    const tick=()=>{
      const left=Math.max(0,DISABLE_MS-(Date.now()-start));
      timerPill.textContent=`Check available in ${Math.ceil(left/1000)}s`;
      if (left<=0){
        clearInterval(disableTimer); disableTimer=null;
        enableCheck(true);
      }
    };
    tick();
    disableTimer=setInterval(tick,200);
  }

  // --- 1:1 mapping always ---
  function plotSquare(){
    const w=cv.width,h=cv.height;
    const s=Math.min(w,h);
    return {s, ox:(w-s)/2, oy:(h-s)/2};
  }
  function worldToCanvas(x,y){
    const {s,ox,oy}=plotSquare();
    const sx=(x-MIN)/RANGE;
    const sy=(y-MIN)/RANGE;
    return {X:ox+sx*s, Y:oy+(1-sy)*s};
  }
  function canvasToWorld(X,Y){
    const {s,ox,oy}=plotSquare();
    const nx=clamp((X-ox)/s,0,1);
    const ny=clamp((Y-oy)/s,0,1);
    const x=MIN+nx*RANGE;
    const y=MIN+(1-ny)*RANGE;
    return {x,y};
  }

  // --- Mask canvases ---
  const maskCv=document.createElement('canvas');
  maskCv.width=maskCv.height=R_N;
  const maskCtx=maskCv.getContext('2d', { willReadFrequently:true });

  const fillCv=document.createElement('canvas');
  fillCv.width=fillCv.height=R_N;
  const fillCtx=fillCv.getContext('2d', { willReadFrequently:true });

  // Critical for crisp boundaries (especially rays):
  maskCtx.imageSmoothingEnabled = false;
  fillCtx.imageSmoothingEnabled = false;

  function boundaryThickness(){
    if(mode===6) return 9;  // thicker to reduce “near-miss” regions on rays
    if(mode===1) return 3;
    return 2;
  }

  function worldToMask(x,y){
    const sx=(x-MIN)/RANGE;
    const sy=(y-MIN)/RANGE;
    const mx=Math.floor(clamp(sx,0,1)*(R_N-1));
    const my=Math.floor((1-clamp(sy,0,1))*(R_N-1));
    return {mx,my};
  }
  function maskToWorld(mx,my){
    const sx=mx/(R_N-1);
    const sy=1-my/(R_N-1);
    return {x:MIN+sx*RANGE, y:MIN+sy*RANGE};
  }

  // --- TeX helpers for mode 6 ---
  function texCoeffI(absIm){
    if (Math.abs(absIm-1)<1e-9) return `\\mathrm{i}`;
    return `${niceNum(absIm)}\\mathrm{i}`;
  }
  function texZMinusA_plain(re,im){
    const r=Math.round(re*2)/2;
    const i=Math.round(im*2)/2;
    let out="z";
    if (Math.abs(r)>1e-9){
      out += (r>0)?`-${niceNum(r)}`:`+${niceNum(-r)}`;
    }
    if (Math.abs(i)>1e-9){
      const term=texCoeffI(Math.abs(i));
      out += (i>0)?`-${term}`:`+${term}`;
    }
    return out;
  }
  function texPiFrac(kOverPi){
    const sign=kOverPi<0?"-":"";
    const a=Math.abs(kOverPi);
    let best={num:0,den:1,err:1e9};
    for(let den=1;den<=12;den++){
      const num=Math.round(a*den);
      const err=Math.abs(a-num/den);
      if(err<best.err) best={num,den,err};
    }
    const {num,den}=best;
    if(num===0) return "0";
    if(den===1){
      if(num===1) return `${sign}\\pi`;
      return `${sign}${num}\\pi`;
    }
    if(num===1) return `${sign}\\frac{\\pi}{${den}}`;
    return `${sign}\\frac{${num}\\pi}{${den}}`;
  }

  // --- Inequalities ---
  function makeIneqVertical(a,dir){
    return { labelTex(){return `x ${dir} ${niceNum(a)}`;}, eval(x,y){return dir===">"?x>a+1e-9:x<a-1e-9;} };
  }
  function makeIneqHorizontal(b,dir){
    return { labelTex(){return `y ${dir} ${niceNum(b)}`;}, eval(x,y){return dir===">"?y>b+1e-9:y<b-1e-9;} };
  }
  function makeIneqLine(m,c,dir){
    return {
      labelTex(){
        const mStr=(Math.abs(m-1)<1e-9)?"":(Math.abs(m+1)<1e-9)?"-":niceNum(m);
        const xPart=(mStr==="")?"x":(mStr==="-")?"-x":`${mStr}x`;
        if(Math.abs(c)<1e-9) return `y ${dir} ${xPart}`;
        return `y ${dir} ${xPart} ${c>=0?"+":"-"} ${niceNum(Math.abs(c))}`;
      },
      eval(x,y){const rhs=m*x+c; return dir===">"?y>rhs+1e-9:y<rhs-1e-9;}
    };
  }
  function makeIneqParabolaFromVertex(a,h,k,dir){
    return {
      labelTex(){
        const b=-2*a*h;
        const c=a*h*h+k;
        const parts=[];
        const add=(coef,tex)=>{
          if(Math.abs(coef)<1e-9) return;
          const s=coef>=0?"+":"-";
          const mag=Math.abs(coef);
          const coefTex=(Math.abs(mag-1)<1e-9)?"":niceNum(mag);
          parts.push({s,t:`${coefTex}${tex}`});
        };
        add(a,"x^2"); add(b,"x"); add(c,"");
        let out="";
        parts.forEach((p,i)=>{ out += (i===0 ? (p.s==="-"?"-":"")+p.t : ` ${p.s} ${p.t}`); });
        if(!out) out="0";
        return `y ${dir} ${out}`;
      },
      eval(x,y){const rhs=a*(x-h)*(x-h)+k; return dir===">"?y>rhs+1e-9:y<rhs-1e-9;}
    };
  }
  function makeIneqCubic(a,b,c,d,dir){
    return {
      labelTex(){
        const parts=[];
        const add=(coef,tex)=>{
          if(Math.abs(coef)<1e-9) return;
          const s=coef>=0?"+":"-";
          const mag=Math.abs(coef);
          const coefTex=(Math.abs(mag-1)<1e-9)?"":niceNum(mag);
          parts.push({s,t:`${coefTex}${tex}`});
        };
        add(a,"x^3"); add(b,"x^2"); add(c,"x"); add(d,"");
        if(!parts.length) parts.push({s:"+",t:"0"});
        let out="";
        parts.forEach((p,i)=>{ out += (i===0 ? (p.s==="-"?"-":"")+p.t : ` ${p.s} ${p.t}`); });
        return `y ${dir} ${out}`;
      },
      eval(x,y){const rhs=a*x*x*x+b*x*x+c*x+d; return dir===">"?y>rhs+1e-9:y<rhs-1e-9;}
    };
  }
  function makeIneqSine(A,B,C,D,dir){
    return {
      labelTex(){ return `y ${dir} ${niceNum(A)} + ${niceNum(B)}\\sin\\!\\left(${niceNum(C)}x + ${niceNum(D)}\\right)`; },
      eval(x,y){const rhs=A+B*Math.sin(C*x+D); return dir===">"?y>rhs+1e-9:y<rhs-1e-9;}
    };
  }
  function makeIneqExpBase(A,B,base,C,dir){
    const isE=(base==="e");
    const baseTex=isE?"\\mathrm{e}":String(base);
    return {
      labelTex(){ return `y ${dir} ${niceNum(A)} + ${niceNum(B)}\\,${baseTex}^{${niceNum(C)}x}`; },
      eval(x,y){
        const pow=isE?Math.exp(C*x):Math.pow(Number(base),C*x);
        const rhs=A+B*pow;
        return dir===">"?y>rhs+1e-9:y<rhs-1e-9;
      }
    };
  }

  // Mode 6:
  function makeIneqCircle(cx,cy,r,dir){
    return {
      labelTex(){ return `\\left|${texZMinusA_plain(cx,cy)}\\right| ${dir} ${niceNum(r)}`; },
      eval(x,y){ const d=Math.hypot(x-cx,y-cy); return dir===">"?d>r+1e-9:d<r-1e-9; }
    };
  }
  function makeIneqArgBetween(cx,cy,lo,hi){
    return {
      labelTex(){ return `${texPiFrac(lo/Math.PI)} < \\arg\\!\\left(${texZMinusA_plain(cx,cy)}\\right) < ${texPiFrac(hi/Math.PI)}`; },
      eval(x,y){
        // arg undefined at centre
        if(Math.hypot(x-cx,y-cy) < 1e-6) return false;
        const ang=Math.atan2(y-cy,x-cx);
        return ang>lo+1e-9 && ang<hi-1e-9;
      }
    };
  }
  function makeIneqBisector(ax,ay,bx,by,dir){
    return {
      labelTex(){ return `\\left|${texZMinusA_plain(ax,ay)}\\right| ${dir} \\left|${texZMinusA_plain(bx,by)}\\right|`; },
      eval(x,y){
        const da=Math.hypot(x-ax,y-ay);
        const db=Math.hypot(x-bx,y-by);
        return dir===">"?da>db+1e-9:da<db-1e-9;
      }
    };
  }

  // --- Shapes (boundaries only) ---
  function applyStrokeStyleWorld(){
    ctx.lineJoin="round";
    ctx.lineCap="round";
  }
  function applyStrokeStyleMask(){
    maskCtx.lineJoin="round";
    maskCtx.lineCap="round";
  }

  function shapeLine(m,c){
    return {
      drawWorld(){
        const pts=[];
        for(const x of [MIN,MAX]){
          const y=m*x+c;
          if(y>=MIN-1e-9 && y<=MAX+1e-9) pts.push({x,y});
        }
        if(Math.abs(m)>1e-12){
          for(const y of [MIN,MAX]){
            const x=(y-c)/m;
            if(x>=MIN-1e-9 && x<=MAX+1e-9) pts.push({x,y});
          }
        }
        if(pts.length<2) return;
        const A=pts[0], B=pts[1];
        const pA=worldToCanvas(A.x,A.y), pB=worldToCanvas(B.x,B.y);
        ctx.beginPath(); ctx.moveTo(pA.X,pA.Y); ctx.lineTo(pB.X,pB.Y); ctx.stroke();
      },
      drawMask(){
        const pts=[];
        for(const x of [MIN,MAX]){
          const y=m*x+c;
          if(y>=MIN-1e-9 && y<=MAX+1e-9) pts.push({x,y});
        }
        if(Math.abs(m)>1e-12){
          for(const y of [MIN,MAX]){
            const x=(y-c)/m;
            if(x>=MIN-1e-9 && x<=MAX+1e-9) pts.push({x,y});
          }
        }
        if(pts.length<2) return;
        const A=pts[0], B=pts[1];
        const pA=worldToMask(A.x,A.y), pB=worldToMask(B.x,B.y);
        maskCtx.beginPath();
        maskCtx.moveTo(pA.mx+0.5,pA.my+0.5);
        maskCtx.lineTo(pB.mx+0.5,pB.my+0.5);
        maskCtx.stroke();
      }
    };
  }
  function shapeVertical(a){
    return {
      drawWorld(){
        const p1=worldToCanvas(a,MIN), p2=worldToCanvas(a,MAX);
        ctx.beginPath(); ctx.moveTo(p1.X,p1.Y); ctx.lineTo(p2.X,p2.Y); ctx.stroke();
      },
      drawMask(){
        const p1=worldToMask(a,MIN), p2=worldToMask(a,MAX);
        maskCtx.beginPath();
        maskCtx.moveTo(p1.mx+0.5,p1.my+0.5);
        maskCtx.lineTo(p2.mx+0.5,p2.my+0.5);
        maskCtx.stroke();
      }
    };
  }
  function shapeHorizontal(b){
    return {
      drawWorld(){
        const p1=worldToCanvas(MIN,b), p2=worldToCanvas(MAX,b);
        ctx.beginPath(); ctx.moveTo(p1.X,p1.Y); ctx.lineTo(p2.X,p2.Y); ctx.stroke();
      },
      drawMask(){
        const p1=worldToMask(MIN,b), p2=worldToMask(MAX,b);
        maskCtx.beginPath();
        maskCtx.moveTo(p1.mx+0.5,p1.my+0.5);
        maskCtx.lineTo(p2.mx+0.5,p2.my+0.5);
        maskCtx.stroke();
      }
    };
  }
  function shapeGraph(fn){
    return {
      drawWorld(){
        const steps=1200;
        let started=false;
        for(let i=0;i<=steps;i++){
          const x=MIN+RANGE*(i/steps);
          const y=fn(x);
          if(!Number.isFinite(y)){ started=false; continue; }
          const p=worldToCanvas(x,y);
          if(!started){ ctx.beginPath(); ctx.moveTo(p.X,p.Y); started=true; }
          else ctx.lineTo(p.X,p.Y);
        }
        if(started) ctx.stroke();
      },
      drawMask(){
        const steps=1200;
        let started=false;
        for(let i=0;i<=steps;i++){
          const x=MIN+RANGE*(i/steps);
          const y=fn(x);
          if(!Number.isFinite(y)){ started=false; continue; }
          const p=worldToMask(x,y);
          if(!started){ maskCtx.beginPath(); maskCtx.moveTo(p.mx+0.5,p.my+0.5); started=true; }
          else maskCtx.lineTo(p.mx+0.5,p.my+0.5);
        }
        if(started) maskCtx.stroke();
      }
    };
  }
  function shapeCircle(cx,cy,r){
    return {
      drawWorld(){
        const steps=900;
        ctx.beginPath();
        for(let i=0;i<=steps;i++){
          const t=i/steps*2*Math.PI;
          const x=cx+r*Math.cos(t), y=cy+r*Math.sin(t);
          const p=worldToCanvas(x,y);
          if(i===0) ctx.moveTo(p.X,p.Y); else ctx.lineTo(p.X,p.Y);
        }
        ctx.stroke();
      },
      drawMask(){
        const steps=900;
        maskCtx.beginPath();
        for(let i=0;i<=steps;i++){
          const t=i/steps*2*Math.PI;
          const x=cx+r*Math.cos(t), y=cy+r*Math.sin(t);
          const p=worldToMask(x,y);
          if(i===0) maskCtx.moveTo(p.mx+0.5,p.my+0.5); else maskCtx.lineTo(p.mx+0.5,p.my+0.5);
        }
        maskCtx.stroke();
      }
    };
  }

  // Stronger ray (and a “cap” at origin) to stop leaks + reduce angle mismatch.
  function shapeRay(cx,cy,theta){
    return {
      drawWorld(){
        const p0=worldToCanvas(cx,cy);
        const p1=worldToCanvas(cx+40*Math.cos(theta), cy+40*Math.sin(theta));
        ctx.beginPath(); ctx.moveTo(p0.X,p0.Y); ctx.lineTo(p1.X,p1.Y); ctx.stroke();
        // small visible dot at vertex looks nicer too
        ctx.save();
        ctx.fillStyle="rgba(17,24,39,0.75)";
        ctx.beginPath(); ctx.arc(p0.X,p0.Y,3.2,0,Math.PI*2); ctx.fill();
        ctx.restore();
      },
      drawMask(){
        const p0=worldToMask(cx,cy);
        const p1=worldToMask(cx+40*Math.cos(theta), cy+40*Math.sin(theta));
        maskCtx.beginPath();
        maskCtx.moveTo(p0.mx+0.5,p0.my+0.5);
        maskCtx.lineTo(p1.mx+0.5,p1.my+0.5);
        maskCtx.stroke();

        // seal the vertex: fill a small disk at the origin of the rays
        maskCtx.beginPath();
        maskCtx.arc(p0.mx+0.5,p0.my+0.5, Math.max(2, boundaryThickness()*0.65), 0, Math.PI*2);
        maskCtx.fillStyle="#000";
        maskCtx.fill();
      }
    };
  }

  // --- Mask -> regions ---
  function drawMaskBoundaries(){
    maskCtx.save();
    maskCtx.setTransform(1,0,0,1,0,0);
    maskCtx.clearRect(0,0,R_N,R_N);
    maskCtx.fillStyle="#fff";
    maskCtx.fillRect(0,0,R_N,R_N);

    applyStrokeStyleMask();
    maskCtx.strokeStyle="#000";
    maskCtx.fillStyle="#000";
    maskCtx.lineWidth=boundaryThickness();

    // hard border as boundary
    maskCtx.strokeRect(0.5,0.5,R_N-1,R_N-1);

    for(const s of shapes) s.drawMask();
    maskCtx.restore();
  }

  function buildRegionsFromMask(){
    const img=maskCtx.getImageData(0,0,R_N,R_N).data;
    regionId=new Int32Array(R_N*R_N);
    regionRep=[];
    regionCount=0;

    // boundary pixels are “dark”
    const isBoundary = (p) => (img[p]+img[p+1]+img[p+2]) < 60*3;

    const qx=new Int32Array(R_N*R_N);
    const qy=new Int32Array(R_N*R_N);

    const idxPix=(x,y)=>4*(y*R_N+x);
    const idxCell=(x,y)=>y*R_N+x;

    for(let y=0;y<R_N;y++){
      for(let x=0;x<R_N;x++){
        const cell=idxCell(x,y);
        if(regionId[cell]!==0) continue;
        if(isBoundary(idxPix(x,y))) continue;

        regionCount++;
        const rid=regionCount;
        let head=0, tail=0;
        qx[tail]=x; qy[tail]=y; tail++;
        regionId[cell]=rid;

        // representative point: we will improve it later (take a point away from boundary)
        regionRep[rid]={mx:x,my:y};

        while(head<tail){
          const cx=qx[head], cy=qy[head]; head++;
          const neigh=[[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]];
          for(const [nx,ny] of neigh){
            if(nx<0||nx>=R_N||ny<0||ny>=R_N) continue;
            const ccell=idxCell(nx,ny);
            if(regionId[ccell]!==0) continue;
            if(isBoundary(idxPix(nx,ny))) continue;
            regionId[ccell]=rid;
            qx[tail]=nx; qy[tail]=ny; tail++;
          }
        }
      }
    }

    // Improve reps: pick a point more central in each region (reduces “wrong side” near boundaries)
    // We do a quick sample scan and pick the first point whose 5x5 neighbourhood stays in same region.
    for(let rid=1; rid<=regionCount; rid++){
      let found=false;
      for(let tries=0; tries<4000 && !found; tries++){
        const mx=(Math.random()*(R_N-1))|0;
        const my=(Math.random()*(R_N-1))|0;
        if(regionId[my*R_N+mx]!==rid) continue;
        let ok=true;
        for(let dy=-2; dy<=2 && ok; dy++){
          for(let dx=-2; dx<=2; dx++){
            const x=mx+dx, y=my+dy;
            if(x<0||x>=R_N||y<0||y>=R_N){ ok=false; break; }
            if(regionId[y*R_N+x]!==rid){ ok=false; break; }
          }
        }
        if(ok){ regionRep[rid]={mx,my}; found=true; }
      }
    }
  }

  function computeTruthRegions(){
    truthRegions=new Set();
    for(let rid=1; rid<=regionCount; rid++){
      const rep=regionRep[rid];
      if(!rep) continue;
      const {x,y}=maskToWorld(rep.mx,rep.my);
      let ok=true;
      for(const inq of ineqs){
        if(!inq.eval(x,y)){ ok=false; break; }
      }
      if(ok) truthRegions.add(rid);
    }
  }

  function rebuildFillOverlay(){
    const img=fillCtx.createImageData(R_N,R_N);
    const d=img.data;
    for(let y=0;y<R_N;y++){
      for(let x=0;x<R_N;x++){
        const rid=regionId[y*R_N+x];
        if(rid>0 && selected.has(rid)){
          const k=4*(y*R_N+x);
          d[k]=249; d[k+1]=115; d[k+2]=22; d[k+3]=70;
        }
      }
    }
    fillCtx.putImageData(img,0,0);
  }

  // --- drawing ---
  function drawAxes(){
    const {s,ox,oy}=plotSquare();
    ctx.lineWidth=2.0;
    ctx.strokeStyle="rgba(17,24,39,0.35)";
    ctx.strokeRect(ox,oy,s,s);

    const p0=worldToCanvas(0,0);
    ctx.strokeStyle="rgba(17,24,39,0.35)";
    ctx.lineWidth=2.1;
    ctx.beginPath(); ctx.moveTo(p0.X,oy); ctx.lineTo(p0.X,oy+s); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ox,p0.Y); ctx.lineTo(ox+s,p0.Y); ctx.stroke();

    ctx.fillStyle="rgba(17,24,39,0.70)";
    ctx.font="14px system-ui,-apple-system,Segoe UI,Roboto,Arial";
    ctx.textAlign="center"; ctx.textBaseline="top";
    for(let x=-12;x<=12;x+=2){
      const p=worldToCanvas(x,0);
      if(p.X<ox-2||p.X>ox+s+2) continue;
      ctx.strokeStyle="rgba(17,24,39,0.25)";
      ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.moveTo(p.X,p0.Y-6); ctx.lineTo(p.X,p0.Y+6); ctx.stroke();
      if(x!==0) ctx.fillText(String(x),p.X,p0.Y+10);
    }
    ctx.textAlign="right"; ctx.textBaseline="middle";
    for(let y=-12;y<=12;y+=2){
      const p=worldToCanvas(0,y);
      if(p.Y<oy-2||p.Y>oy+s+2) continue;
      ctx.strokeStyle="rgba(17,24,39,0.25)";
      ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.moveTo(p0.X-6,p.Y); ctx.lineTo(p0.X+6,p.Y); ctx.stroke();
      if(y!==0) ctx.fillText(String(y),p0.X-10,p.Y);
    }
  }

  function drawAll(){
    if(!ctx) return;
    ctx.clearRect(0,0,cv.width,cv.height);
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,cv.width,cv.height);

    const {s,ox,oy}=plotSquare();

    // selection overlay
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(fillCv, 0,0,R_N,R_N, ox,oy,s,s);
    ctx.imageSmoothingEnabled = true;

    // boundaries
    applyStrokeStyleWorld();
    ctx.strokeStyle="rgba(17,24,39,0.55)";
    ctx.lineWidth=(mode===6?3.2:2.8);
    for(const sh of shapes) sh.drawWorld();

    drawAxes();
  }

  // --- render inequalities ---
  function renderIneqList(){
    levelPill.textContent = `Level ${level} / 6`;
    ineqList.innerHTML="";
    ineqs.forEach((inq,i)=>{
      const d=document.createElement("div");
      d.className="ineq";
      d.innerHTML=`<div class="k">Inequality ${i+1}</div><div class="v">\\(${inq.labelTex()}\\)</div>`;
      ineqList.appendChild(d);
    });
    if(window.MathJax?.typesetPromise){
      MathJax.typesetClear?.([ineqList]);
      MathJax.typesetPromise([ineqList]).catch(()=>{});
    }
  }

  function modeDescription(m){
    return [
      "Mode 0: only x=a and y=b.",
      "Mode 1: always draws 6 straight-line graphs; only Level-many of them are used as inequalities (others are red herrings).",
      "Mode 2: lines + parabolas.",
      "Mode 3: lines + parabolas + cubics.",
      "Mode 4: lines + sine waves.",
      "Mode 5: lines + exponentials (e upright).",
      "Mode 6: complex loci (upright i; arg-between uses rays; thicker mask to avoid mis-shading)."
    ][m] || "";
  }

  // --- generators ensuring: non-empty, region cap ---
  function generateMode0(k){
    shapes=[]; const pool=[];
    for(let i=0;i<4;i++){
      if(Math.random()<0.5){
        const a=Math.round(rnd(-9,9)*2)/2;
        shapes.push(shapeVertical(a));
        pool.push(()=>makeIneqVertical(a, Math.random()<0.5?">":"<"));
      } else {
        const b=Math.round(rnd(-9,9)*2)/2;
        shapes.push(shapeHorizontal(b));
        pool.push(()=>makeIneqHorizontal(b, Math.random()<0.5?">":"<"));
      }
    }
    ineqs=[];
    for(let i=0;i<k;i++) ineqs.push(pool[i%pool.length]());
  }

  // Mode 1: ALWAYS 6 graphs. Only Level-many become inequalities (others are red herrings).
  // Mostly y=mx+c; occasionally include one x=a line.
  function generateMode1(k){
    shapes=[]; ineqs=[];
    const pool=[];

    // decide if we include a vertical line this round (rare)
    const includeVertical = (Math.random()<0.25);
    let verticalInfo=null;

    // build 6 boundaries
    const used=new Set();
    for(let i=0;i<6;i++){
      if(includeVertical && !verticalInfo && i===0){
        const a=Math.round(rnd(-8,8)*2)/2;
        verticalInfo={a};
        shapes.push(shapeVertical(a));
        pool.push(()=>makeIneqVertical(a, Math.random()<0.5?">":"<"));
        used.add(`v:${a}`);
        continue;
      }
      // line
      let m,c,key;
      for(let t=0;t<40;t++){
        m=randSlope();
        c=Math.round(rnd(-8,8)*2)/2;
        key=`l:${m}:${c}`;
        if(!used.has(key)) break;
      }
      used.add(key);
      shapes.push(shapeLine(m,c));
      pool.push(()=>makeIneqLine(m,c, Math.random()<0.5?">":"<"));
    }

    // choose k distinct inequalities from pool
    const idxs=[0,1,2,3,4,5];
    for(let i=idxs.length-1;i>0;i--){
      const j=(Math.random()*(i+1))|0;
      [idxs[i],idxs[j]]=[idxs[j],idxs[i]];
    }
    for(let i=0;i<k;i++){
      ineqs.push(pool[idxs[i]]());
    }
  }

  function randomVertexWithin(){
    return { h: Math.round(rnd(-8,8)*2)/2, k: Math.round(rnd(-8,8)*2)/2 };
  }

  function generateMode2(k){
    shapes=[]; const pool=[];
    const a=pick([-1.5,-1,-0.5,0.5,1,1.5]);
    const {h,k:kv}=randomVertexWithin();
    shapes.push(shapeGraph(x=>a*(x-h)*(x-h)+kv));
    pool.push(()=>makeIneqParabolaFromVertex(a,h,kv, Math.random()<0.5?">":"<"));

    for(let i=0;i<4;i++){
      const m=randSlope();
      const c=Math.round(rnd(-8,8)*2)/2;
      shapes.push(shapeLine(m,c));
      pool.push(()=>makeIneqLine(m,c, Math.random()<0.5?">":"<"));
    }

    ineqs=[];
    for(let i=0;i<k;i++) ineqs.push(pool[i]());
  }

  function generateMode3(k){
    shapes=[]; const pool=[];

    const A=(Math.random()<0.5?-1:1)*pick([0.1,0.15,0.2]);
    const B=Math.round(rnd(-1.5,1.5)*2)/2;
    const C=Math.round(rnd(-2,2)*2)/2;
    const D=Math.round(rnd(-4,4)*2)/2;

    shapes.push(shapeGraph(x=>A*x*x*x+B*x*x+C*x+D));
    pool.push(()=>makeIneqCubic(A,B,C,D, Math.random()<0.5?">":"<"));

    const ap=pick([-1.5,-1,-0.5,0.5,1,1.5]);
    const {h,k:kv}=randomVertexWithin();
    shapes.push(shapeGraph(x=>ap*(x-h)*(x-h)+kv));
    pool.push(()=>makeIneqParabolaFromVertex(ap,h,kv, Math.random()<0.5?">":"<"));

    for(let i=0;i<3;i++){
      const m=randSlope();
      const c=Math.round(rnd(-8,8)*2)/2;
      shapes.push(shapeLine(m,c));
      pool.push(()=>makeIneqLine(m,c, Math.random()<0.5?">":"<"));
    }

    ineqs=[];
    for(let i=0;i<k;i++) ineqs.push(pool[i]());
  }

  function generateMode4(k){
    shapes=[]; const pool=[];
    const A=Math.round(rnd(-3,3)*2)/2;
    const B=pick([1,1.5,2,2.5])*(Math.random()<0.5?-1:1);
    const C=pick([0.5,1,1.5,2]);
    const D=Math.round(rnd(-Math.PI,Math.PI)*100)/100;
    shapes.push(shapeGraph(x=>A + B*Math.sin(C*x + D)));
    pool.push(()=>makeIneqSine(A,B,C,D, Math.random()<0.5?">":"<"));

    for(let i=0;i<4;i++){
      const m=randSlope();
      const c=Math.round(rnd(-8,8)*2)/2;
      shapes.push(shapeLine(m,c));
      pool.push(()=>makeIneqLine(m,c, Math.random()<0.5?">":"<"));
    }

    ineqs=[];
    for(let i=0;i<k;i++) ineqs.push(pool[i]());
  }

  function generateMode5(k){
    shapes=[]; const pool=[];
    const A=Math.round(rnd(-3,3)*2)/2;
    const B=pick([0.5,1,1.5,2])*(Math.random()<0.5?-1:1);
    const base=pick([2,3,5,10,"e"]);
    const C=pick([0.1,0.15,0.2,0.25,0.3])*(Math.random()<0.5?-1:1);

    shapes.push(shapeGraph(x=>{
      const pow=(base==="e")?Math.exp(C*x):Math.pow(Number(base),C*x);
      return A + B*pow;
    }));
    pool.push(()=>makeIneqExpBase(A,B,base,C, Math.random()<0.5?">":"<"));

    for(let i=0;i<4;i++){
      const m=randSlope();
      const c=Math.round(rnd(-8,8)*2)/2;
      shapes.push(shapeLine(m,c));
      pool.push(()=>makeIneqLine(m,c, Math.random()<0.5?">":"<"));
    }

    ineqs=[];
    for(let i=0;i<k;i++) ineqs.push(pool[i]());
  }

  function randomPiAngle(){
    const steps=[-5/6,-3/4,-2/3,-1/2,-1/3,-1/4,-1/5,-1/6,0,1/6,1/5,1/4,1/3,1/2,2/3,3/4,5/6];
    return pick(steps)*Math.PI;
  }

  function generateMode6(k){
    shapes=[]; ineqs=[];
    const loci=[];

    for(let i=0;i<6;i++){
      const t=Math.random();
      if(t<0.38){
        const cx=Math.round(rnd(-6,6)*2)/2;
        const cy=Math.round(rnd(-6,6)*2)/2;
        const r=Math.round(rnd(1.5,5)*2)/2;
        const dir=Math.random()<0.5?">":"<";
        loci.push({type:"circle", cx,cy,r,dir});
      } else if(t<0.68){
        const cx=Math.round(rnd(-4,4)*2)/2;
        const cy=Math.round(rnd(-4,4)*2)/2;
        let lo=randomPiAngle(), hi=randomPiAngle();
        if(lo>hi){const tmp=lo; lo=hi; hi=tmp;}
        if(hi-lo<Math.PI/7){
          hi=lo+Math.PI/3;
          if(hi>Math.PI-Math.PI/12) hi=Math.PI-Math.PI/12;
        }
        loci.push({type:"argBetween", cx,cy,lo,hi});
      } else {
        const ax=Math.round(rnd(-7,7)*2)/2;
        const ay=Math.round(rnd(-7,7)*2)/2;
        let bx=Math.round(rnd(-7,7)*2)/2;
        let by=Math.round(rnd(-7,7)*2)/2;
        if(Math.hypot(ax-bx,ay-by)<2){ bx+=3; by-=2; }
        const dir=Math.random()<0.5?">":"<";
        loci.push({type:"bisector", ax,ay,bx,by,dir});
      }
    }

    // boundaries from all loci (always draw 6 loci worth of boundaries)
    for(const L of loci){
      if(L.type==="circle"){
        shapes.push(shapeCircle(L.cx,L.cy,L.r));
      } else if(L.type==="argBetween"){
        shapes.push(shapeRay(L.cx,L.cy,L.lo));
        shapes.push(shapeRay(L.cx,L.cy,L.hi));
      } else {
        const vx=(L.bx-L.ax), vy=(L.by-L.ay);
        const rhs=(L.bx*L.bx+L.by*L.by)-(L.ax*L.ax+L.ay*L.ay);
        if(Math.abs(vy)>1e-9){
          shapes.push(shapeLine((-vx)/vy, (rhs/2)/vy));
        } else {
          shapes.push(shapeVertical((rhs/2)/vx));
        }
      }
    }

    // pick k inequalities with diversity if level>1
    const idxs=[0,1,2,3,4,5];
    for(let i=idxs.length-1;i>0;i--){
      const j=(Math.random()*(i+1))|0;
      [idxs[i],idxs[j]]=[idxs[j],idxs[i]];
    }

    let chosen=[], types=new Set();
    for(const i of idxs){
      const L=loci[i];
      chosen.push(L);
      types.add(L.type);
      if(chosen.length===k && (level===1 || types.size>=2)) break;
    }
    if(level>1 && types.size<2) return false;

    for(const L of chosen){
      if(L.type==="circle") ineqs.push(makeIneqCircle(L.cx,L.cy,L.r,L.dir));
      else if(L.type==="argBetween") ineqs.push(makeIneqArgBetween(L.cx,L.cy,L.lo,L.hi));
      else ineqs.push(makeIneqBisector(L.ax,L.ay,L.bx,L.by,L.dir));
    }
    return true;
  }

  function generateForModeAndLevel(){
    const targetK=clamp(level,1,6);
    const MAX_TRIES=1200;

    for(let t=0;t<MAX_TRIES;t++){
      if(mode===0) generateMode0(targetK);
      else if(mode===1) generateMode1(targetK);
      else if(mode===2) generateMode2(targetK);
      else if(mode===3) generateMode3(targetK);
      else if(mode===4) generateMode4(targetK);
      else if(mode===5) generateMode5(targetK);
      else if(mode===6){
        const ok=generateMode6(targetK);
        if(!ok) continue;
      }

      drawMaskBoundaries();
      buildRegionsFromMask();
      if(regionCount>MAX_REGIONS_ALLOWED) continue;

      computeTruthRegions();
      if(truthRegions.size===0) continue;

      // each inequality alone must be non-empty
      let okEach=true;
      for(const inq of ineqs){
        let any=false;
        for(let rid=1; rid<=regionCount; rid++){
          const rep=regionRep[rid];
          const {x,y}=maskToWorld(rep.mx,rep.my);
          if(inq.eval(x,y)){ any=true; break; }
        }
        if(!any){ okEach=false; break; }
      }
      if(!okEach) continue;

      return true;
    }
    return false;
  }

  // --- round setup ---
  function newRound(nextLevel){
    level = clamp(nextLevel,1,6);
    selected = new Set();
    failChecks=0;
    showAfter2(false);
    statusBox.style.display="none";
    hideHint();
    clearCooldown();

    modeHelp.textContent = modeDescription(mode);

    const ok=generateForModeAndLevel();
    if(!ok) showHint("Could not generate a valid set quickly. Press New image.");

    renderIneqList();
    rebuildFillOverlay();
    drawAll();
  }

  // --- selection ---
  function regionAtWorld(x,y){
    const {mx,my}=worldToMask(x,y);
    return regionId ? regionId[my*R_N+mx] : 0;
  }

  function getCanvasXY(evt){
    const rect=cv.getBoundingClientRect();
    const clientX = (evt.touches && evt.touches.length) ? evt.touches[0].clientX : evt.clientX;
    const clientY = (evt.touches && evt.touches.length) ? evt.touches[0].clientY : evt.clientY;
    return {
      x:(clientX-rect.left)*(cv.width/rect.width),
      y:(clientY-rect.top)*(cv.height/rect.height)
    };
  }

  let isDown=false, lastRid=null;
  function toggleAtEvent(evt){
    const p=getCanvasXY(evt);
    const w=canvasToWorld(p.x,p.y);
    const rid=regionAtWorld(w.x,w.y);
    if(!rid) return 0;
    if(selected.has(rid)) selected.delete(rid); else selected.add(rid);
    rebuildFillOverlay();
    drawAll();
    return rid;
  }
  function onDown(evt){
    evt.preventDefault();
    isDown=true;
    lastRid=toggleAtEvent(evt);
  }
  function onMove(evt){
    if(!isDown) return;
    evt.preventDefault();
    const p=getCanvasXY(evt);
    const w=canvasToWorld(p.x,p.y);
    const rid=regionAtWorld(w.x,w.y);
    if(!rid || rid===lastRid) return;
    lastRid=rid;
    if(selected.has(rid)) selected.delete(rid); else selected.add(rid);
    rebuildFillOverlay();
    drawAll();
  }
  function onUp(evt){
    evt.preventDefault();
    isDown=false;
    lastRid=null;
  }

  function bindInputs(){
    cv.addEventListener('mousedown', onDown);
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    cv.addEventListener('touchstart', onDown, {passive:false});
    window.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('touchend', onUp, {passive:false});
  }

  // --- check logic ---
  function doCheck(){
    let correct=0, incorrect=0, missed=0;
    for(const rid of selected){
      if(truthRegions.has(rid)) correct++; else incorrect++;
    }
    for(const rid of truthRegions){
      if(!selected.has(rid)) missed++;
    }
    const perfect=(incorrect===0 && missed===0);
    showStatus(`${correct} regions correct, ${incorrect} regions incorrect, ${missed} regions missed.`, perfect?"good":"bad");

    if(perfect){
      failChecks=0;
      showAfter2(false);
      clearCooldown();
      if(level<6){
        showHint(`Correct! New set generated for Level ${level+1}.`);
        setTimeout(hideHint, 900);
        newRound(level+1);
      }else{
        showHint("Correct! Level 6 complete. Press New image to restart.");
      }
      return;
    }

    failChecks++;
    showAfter2(failChecks>=2);
    startDisableCountdown();
  }

  // --- buttons ---
  checkBtn.addEventListener('click', ()=>{ if(!checkBtn.disabled) doCheck(); });
  tryAgainBtn.addEventListener('click', ()=>{ showAfter2(false); });

  showAnsBtn.addEventListener('click', ()=>{
    selected = new Set(truthRegions);
    rebuildFillOverlay();
    drawAll();
    showHint("Correct answer shown (filled). Press New image to continue or Clear shading to retry.");
    setTimeout(hideHint, 1800);
  });

  clearBtn.addEventListener('click', ()=>{
    selected.clear();
    rebuildFillOverlay();
    drawAll();
    showAfter2(false);
    statusBox.style.display="none";
  });

  newBtn.addEventListener('click', ()=>{
    showAfter2(false);
    clearCooldown();
    newRound(level);
  });

  modeSel.addEventListener('change', ()=>{
    mode=Number(modeSel.value)||0;
    level=1;
    showAfter2(false);
    newRound(1);
  });

  // init
  function init(){
    if(!cv || !ctx){
      // fail loudly but nicely
      document.getElementById('hintBox').style.display="block";
      document.getElementById('hintBox').textContent="Canvas failed to initialise (no 2D context).";
      return;
    }
    mode=Number(modeSel.value)||0;
    modeHelp.textContent = modeDescription(mode);
    bindInputs();
    newRound(1);
  }
  window.addEventListener('load', init);
})();
</script>
</body>
</html>
